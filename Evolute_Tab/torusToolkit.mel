//// 	torus Toolkit////	created by Goa Lobaugh
//		additional coding by Nick Johnson, Casey Pyke//	c2009/2010 liquid buddha studios////	BEST RESULTS WHEN STARTING FROM A FRESH SCENE FILE////	$NumLoops = number of "laps" around torus before reconnecting////	$CentRot = degree of rotation about the center. //				Defined by USER (spacing between nodes)//	$AxisRot	= degree of rotation about the torus-core//				defined by Number of Loops * 360 / Iterations//	$speed = number of frames for 1 full 360 turn of locator//			= suggest 100 frames/revolution/////*  Proc list:	evoCurve	evoSphere	evoTori	evoBuild	*/

proc tt_revAnim( int $grpNum, int $revCheck, int $animCycle )
{
	if($grpNum != 0 && $revCheck == 0)
	{
		setKeyframe -t 1 -v 0 ("rotateLoc_" + $grpNum + "_1.rz"); 
		setKeyframe -t $animCycle -v 360 ("rotateLoc_" + $grpNum + "_1.rz");
	
		
		setInfinity -poi cycle ("rotateLoc_" + $grpNum + "_1.rz");
		
	}
	if($grpNum != 0 && $revCheck == 1)
	{
		setKeyframe -t 1 -v 360 ("rotateLoc_" + $grpNum + "_1.rz"); 
		setKeyframe -t $animCycle -v 0 ("rotateLoc_" + $grpNum + "_1.rz");

		
		setInfinity -poi cycle ("rotateLoc_" + $grpNum + "_1.rz");
		
	}
}
global proc tt_revAnimCheck()
{
	int $grpSel[] = `textScrollList -q -sii torus_textList`;
	int $grpNum = $grpSel[0];

	int $revCheck = `checkBoxGrp -q -v1 ttRevAnim`;
	int $animCycle = `intSliderGrp -q -v fldCycle`;

	tt_revAnim( $grpNum, $revCheck, $animCycle );
}
//----------------------------------------------------------------------//----------------------------------------------------------------------//START OF EVOCURVE PROCEDURE//----------------------------------------------------------------------
//----------------------------------------------------------------------
global proc string evoCurve (float $tRad, float $HR, int $NumLoops, float $CentRot, float $speed) {//----------------------------------------------------------------------// variables & declarations//----------------------------------------------------------------------float $AxisRot;float $i;float $x = 1;float $CurrentRot;float $WRad;int $et = `radioButtonGrp -query -sl evoType`;//----------------------------------------------------------------------//	formulas//----------------------------------------------------------------------$i = (($NumLoops + 1) * 360 / $CentRot);$AxisRot = $NumLoops * 360/($i);$WRad =  ($tRad*$HR) + $tRad;

$confirm = 1;
/*
if($i > 699)
{	string $tori_notify = `confirmDialog
		-title "Risk of slow down"
		-message ("create " + $i + " nodes?")
		-button "Continue"
		-button "Cancel"
		-defaultButton "Continue"
		-cancelButton "Cancel"`;
	//print($tori_notify + "\n");
	if($tori_notify == "Cancel")
	{
		$confirm = 0;
	}
}
*/

if($confirm == 1)
{	string $notes;	$notes = "Torus Radius/HR: " + $tRad + " / " + $HR + "\n";	$notes = $notes + "Number of loops: " + $NumLoops + "\n";	$notes = $notes + "Rotation: " + $CentRot + "\n";	$notes = $notes + "frames per cycle: " + $speed + "\n";	$centerLoc = `spaceLocator -p 0 0 0`;	setAttr ($centerLoc[0] + ".localScaleX") .1;	setAttr ($centerLoc[0] + ".localScaleY") .1;	setAttr ($centerLoc[0] + ".localScaleZ") .1;	$rotateLoc = `spaceLocator -p 0 0 0`;	xform -t $tRad 0 0;	CenterPivot;	setAttr ($rotateLoc[0] + ".localScaleX") .1;	setAttr ($rotateLoc[0] + ".localScaleY") .1;	setAttr ($rotateLoc[0] + ".localScaleZ") .1;	$waveLoc = `spaceLocator -p 0 0 0`;	xform -t $WRad 0 0;	CenterPivot;	setAttr ($waveLoc[0] + ".localScaleX") .7;	setAttr ($waveLoc[0] + ".localScaleY") .7;	setAttr ($waveLoc[0] + ".localScaleZ") .7;	parent $waveLoc[0] $rotateLoc[0];	parent $rotateLoc[0] $centerLoc[0];	$locGroup = `group $centerLoc[0]`;	//----------------------------------------------------------------------	//		part 2	//		setup animation keyframes, and setDrivenKeys for other nodes	//----------------------------------------------------------------------	//----------------------------------------------------------------------	//	setup the initial keyframes for RotateLocator1	//----------------------------------------------------------------------	
	$tori_autoKey = `autoKeyframe -q -state`;
	if($tori_autoKey == 1)
	{
		autoKeyframe -e -state 0;
	}
/*	currentTime 1;	setAttr ($rotateLoc[0] + ".rotateZ") 0;	setKeyframe ($rotateLoc[0] + ".rz");	currentTime $speed ;	setAttr ($rotateLoc[0] + ".rotateZ") 360;	setKeyframe ($rotateLoc[0] + ".rz");	setInfinity -poi cycle ($rotateLoc[0] + ".rz");*/	currentTime 1;	//----------------------------------------------------------------------	//DUPLICATE LOCATORS AND ROTATE INTO STARTING POSITION	//----------------------------------------------------------------------	for($x=1;$x<$i;$x++)	{		select -r $centerLoc[0];		duplicate;		rotate 0 ($CentRot * $x) 0;		pickWalk -d down;		pickWalk -d right;		rotate -r 0 0 ($AxisRot * $x);		}
	//----------------------------------------------------------------------	//RENAME LOCATORS AND GROUP	//CONNECT ROTATE LOCATORS .rotateZ	//----------------------------------------------------------------------	$grpNum = 0;	$editMode = `radioButtonGrp -q -sl editRadio`;	if( `objExists "locatorGroup_*"` != 0 && $editMode == 2)	{		select -r "locatorGroup_*";		$grpNumArray = `ls -sl`;		$grpNum = `size($grpNumArray)`;	}	else if( `objExists "locatorGroup_*"` != 0 && $editMode == 1)	{		int $evoNumArray[] = `textScrollList -q -sii torus_textList`;
		$grpNum = ($evoNumArray[0]-1);	}	$groupArray = `listRelatives -c $locGroup`;	$groupSize = `size($groupArray)`;	for($e=0;$e<$groupSize;$e++)	{		select -r $groupArray[$e];		rename ("centerLoc_" + ($grpNum+1) + "_" + ($e+1));		pickWalk -d down;		pickWalk -d right;		rename ("rotateLoc_" + ($grpNum+1) + "_" + ($e+1));		pickWalk -d down;		pickWalk -d right;		rename ("waveLoc_" + ($grpNum+1) + "_" + ($e+1));

		//----------------------------------------------------------------------
		//set driven keys for rotate and wave locators
		//----------------------------------------------------------------------
		if($e>0)		{			setAttr ("rotateLoc_" + ($grpNum+1) + "_1.rotate") -type "double3" 0 0 0;			$CurrentRot = `getAttr ("rotateLoc_" + ($grpNum+1) + "_" + ($e+1) + ".rz")` + 360;			setDrivenKeyframe -currentDriver ("rotateLoc_" + ($grpNum+1) + "_1.rz") ("rotateLoc_" + ($grpNum+1) + "_" + ($e+1) + ".rz");					setAttr ("rotateLoc_" + ($grpNum+1) + "_1.rz") 360;			setAttr -k 0 ("rotateLoc_" + ($grpNum+1) + "_" + ($e+1) + ".rz") $CurrentRot;			setDrivenKeyframe -currentDriver ("rotateLoc_" + ($grpNum+1) + "_1.rz") ("rotateLoc_" + ($grpNum+1) + "_" + ($e+1) + ".rz");			connectAttr ("rotateLoc_" + ($grpNum+1) + "_1.tx") ("rotateLoc_" + ($grpNum+1) + "_" + ($e+1) + ".tx");			connectAttr ("waveLoc_" + ($grpNum+1) + "_1.tx") ("waveLoc_" + ($grpNum+1) + "_" + ($e+1) + ".tx");		}	}	rename $locGroup ("locatorGroup_" + ($grpNum+1));
	select -r ("locatorGroup_" + ($grpNum+1));

	addAttr -ln "heightRatio"  -at double -min 0.001 ("locatorGroup_" + ($grpNum+1));
	setAttr -e-keyable true ("locatorGroup_" + ($grpNum+1) + ".heightRatio");
	$multDiv = `shadingNode -asUtility multiplyDivide`;
	connectAttr -f ("locatorGroup_" + ($grpNum+1) + ".heightRatio") ($multDiv + ".input1X");
	connectAttr -f ($multDiv + ".outputX") ("waveLoc_" + ($grpNum+1) + "_1.translateX");
	setAttr ("locatorGroup_" + ($grpNum+1) + ".heightRatio") $HR;

	addAttr -ln "radius"  -at double -min 0.001 ("locatorGroup_" + ($grpNum+1));
	setAttr -e-keyable true ("locatorGroup_" + ($grpNum+1) + ".radius");
	connectAttr -f ("locatorGroup_" + ($grpNum+1) + ".radius") ("rotateLoc_" + ($grpNum+1) + "_1.translateX");
	connectAttr -f ("locatorGroup_" + ($grpNum+1) + ".radius") ($multDiv + ".input2X");
	setAttr ("locatorGroup_" + ($grpNum+1) + ".radius") $tRad;

	setAttr -lock true ("locatorGroup_" + ($grpNum+1) + ".heightRatio");
	setAttr -lock true ("locatorGroup_" + ($grpNum+1) + ".radius");

	xform -cp;
	select -cl;

	int $revCheck = `checkBoxGrp -q -v1 ttRevAnim`;
	tt_revAnim( ($grpNum+1), $revCheck, $speed );	if(`objExists locatorGrp` == 0)	{		$locGrp = `group -em`; 		xform -os -piv 0 0 0;		parent ("locatorGroup_" + ($grpNum+1)) $locGrp;			select -r $locGrp;		$torusGrp = `group`;		xform -os -piv 0 0 0;		setAttr ($locGrp + ".v") 0;		rename $locGrp "locatorGrp";		rename $torusGrp "evoGrp";	}	else	{		parent ("locatorGroup_" + ($grpNum+1)) locatorGrp;	}

	//----------------------------------------------------------------------
	//move on to curve/sphere/torus creation
	//----------------------------------------------------------------------	if($et == 1)	{		evoCurveCreate($grpNum);	}	else if($et == 2)	{		evoSphereCreate($grpNum);	}	else if($et == 3)	{		evoTorusCreate($grpNum);	}
	else if($et == 4)	{		evoPlaneCreate($grpNum);	}	//print ($notes);

	//Update text scroll list in UI
	torus_updateTextList();

	}




return "\n evolute curve complete";}
//----------------------------------------------------------------------//END OF EVOCURVE PROCEDURE//----------------------------------------------------------------------

//----------------------------------------------------------------------//----------------------------------------------------------------------//EVOCURVE CREATION PROCEDURE//----------------------------------------------------------------------
//----------------------------------------------------------------------

global proc evoCurveCreate(int $grpNum){//----------------------------------------------------------------------//----------------------------------------------------------------------//	-	Create a NURBS curve with enough CVs to match to WaveLocators.  //	-	select each CV and make it into a cluster.  (name clusters "C1", "C2", ect...)  //	-	pointConstrain Cluster to WaveLocator//	-	parent Cluster to WaveLocator1;//	- 	cleanup point constraints (delete)//----------------------------------------------------------------------//----------------------------------------------------------------------string  $allObjects[];//----------------------------------------------------------------------//		Create a NURBS curve with enough CVs  //----------------------------------------------------------------------$evoCurve = `curve -p 0 0 0` ;$x = 1;select -r ("waveLoc_" + ($grpNum+1) + "_Shape*");string  $obj;$allObjects = `ls -sl`;	for ( $obj in $allObjects ) 	{		if ( `nodeType $obj` == "locator" ) 		{			float $tx[] = `getAttr $obj.lpx`;			float $ty[] = `getAttr $obj.lpy`;			float $tz[] = `getAttr $obj.lpz`;			curve -a -p  $tx[0] $ty[0] $tz[0] $evoCurve;//			print ($tx[0] + " " +$ty[0] + " " +$tz[0] + "\n") ;//			print ($obj + "\n");		}		$x++;	}//----------------------------------------------------------------------//	create a cluster around the curve.cv and constrain to WaveLocators. //----------------------------------------------------------------------select -r ("waveLoc_" + ($grpNum+1) + "_*");select -d ("waveLoc_" + ($grpNum+1) + "_Shape*");$x = 1;$allObjects = `ls -sl`;	for ( $obj in $allObjects ) 	{		if ( `nodeType $obj` != "locator" ) 		{			select -cl;			string $nm = ("C_" + ($grpNum+1) + "_" + $x);			cluster -n $nm ($evoCurve + ".cv[" + $x + "]");			$nm = $nm + "Handle";			pointConstraint -offset 0 0 0 -weight 1 $obj $nm;//			print ($nm + " cluster around CV " + $x + " is constrained to " + $obj + "\n");		}		$x++;	}//----------------------------------------------------------------------//	final CV handling//----------------------------------------------------------------------	float $sz = `size $allObjects`;	string $nm = ("C_" + ($grpNum+1) + "_" + $x);	cluster -n $nm ($evoCurve + ".cv[0]");	$nm = $nm + "Handle";	pointConstraint -offset 0 0 0 -weight 1 $obj $nm;//	print ($nm + " cluster around CV " + $x + " is constrained to " + $obj + "\n");		closeCurve -ch 1 -ps 0 -rpo 1 -bb 0.9 -bki 1 -p 0.1 $evoCurve;//----------------------------------------------------------------------//	parenting pass//----------------------------------------------------------------------select -r ("waveLoc_" + ($grpNum+1) + "_*");select -d ("waveLoc_" + ($grpNum+1) + "_Shape*");$x = 1;$allObjects = `ls -sl`;	for ( $obj in $allObjects ) 	{		if ($x == 1)		{			string $nm = ("C_" + ($grpNum+1) + "_" + $x + "Handle");			parent  $nm $obj;//			print ($nm + " parented to " + $obj + "\n");		}		$x++;		if ( `nodeType $obj` != "locator" ) 		{			string $nm = ("C_" + ($grpNum+1) + "_" + $x + "Handle");			parent  $nm $obj;//			print ($nm + " parented to " + $obj + "\n");		}	}//	group and notaterename $evoCurve ("evoCurve_" + ($grpNum+1));select -cl;	if(`objExists curveGrp` == 0)	{	$curveGrp = `group -em`; 	xform -os -piv 0 0 0;	parent ("evoCurve_" + ($grpNum+1)) $curveGrp;		parent $curveGrp evoGrp;	rename $curveGrp "curveGrp";	}	else	{	parent ("evoCurve_" + ($grpNum+1)) curveGrp;	}// updateAENotesStatus( "|evoCurveGroup01","notes");}


//----------------------------------------------------------------------//----------------------------------------------------------------------//EVO SPHERE PROCEDURE//----------------------------------------------------------------------//----------------------------------------------------------------------

global proc evoSphereCreate(int $grpNum){/*	---------------------------------------------------		Part 3	-	Create a NURBS sphere  	-	pointConstrain Sphere to WaveLocator	-	parent Sphere to WaveLocator	-	rinse and repeat	---------------------------------------------------*/	//print ("... ... ... create spheres, locate and parent\n");$SphereR = `floatSliderGrp -q -v fldSize`;string  $allObjects[];select ("waveLoc_" + ($grpNum+1) + "_*");select -d ("waveLoc_" + ($grpNum+1) + "_Shape*");$x = 1;string  $obj;$allObjects = `ls -sl`;	for ( $obj in $allObjects ) 	{//		if ( `nodeType $obj` == "locator" ) //		{			$nm = `sphere -r $SphereR`;
			rename $nm[0] ("evoSphere_" + ($grpNum+1) + "_" + $x);			rename $nm[1] ("make_evoSphere_" + ($grpNum+1) + "_" + $x);			pointConstraint  $obj ("evoSphere_" + ($grpNum+1) + "_" + $x);			select -r $obj ("evoSphere_" + ($grpNum+1) + "_" + $x);			parentConstraint -mo -weight 1;
//		}		$x++;	}select -r ("evoSphere_" + ($grpNum+1) + "_*");select -d ("evoSphere_" + ($grpNum+1) + "_Shape*");select -d ("evoSphere_" + ($grpNum+1) + "_*_parentConstraint1");select -d ("evoSphere_" + ($grpNum+1) + "_*_pointConstraint1");$sphereArray = `ls -sl`;$sphereArraySize = `size($sphereArray)`;select -cl;for($i=1;$i<=$sphereArraySize;$i++){	if(`objExists "sphereGrp"` == 0 && `objExists ("evoSphereGrp_" + ($grpNum+1))` == 0)	{		$sphereGrp = `group -em`; 		xform -os -piv 0 0 0;		$evoSphereGrp = `group -em`; 		xform -os -piv 0 0 0;		parent ("evoSphere_" + ($grpNum+1) + "_" + $i) $evoSphereGrp;			parent $evoSphereGrp $sphereGrp;		parent $sphereGrp evoGrp;		rename $sphereGrp "sphereGrp";		rename $evoSphereGrp ("evoSphereGrp_" + ($grpNum+1));	}	else if(`objExists "sphereGrp"` == 1 && `objExists ("evoSphereGrp_" + ($grpNum+1))` == 0)	{		$evoSphereGrp = `group -em`; 		xform -os -piv 0 0 0;		parent ("evoSphere_" + ($grpNum+1) + "_" + $i) $evoSphereGrp;			parent $evoSphereGrp sphereGrp;			rename $evoSphereGrp ("evoSphereGrp_" + ($grpNum+1));	}	else	{		parent ("evoSphere_" + ($grpNum+1) + "_" + $i) ("evoSphereGrp_" + ($grpNum+1));	}}// updateAENotesStatus( "|evoCurveGroup01","notes");}


//----------------------------------------------------------------------
//----------------------------------------------------------------------//EVO TORUS PROCEDURE//----------------------------------------------------------------------
//----------------------------------------------------------------------


global proc evoTorusCreate(int $grpNum){

/*	---------------------------------------------------		Part 3	-	Create a NURBS TORUS  	-	pointConstrain TORUS to WaveLocator	-	parent TORUS to WaveLocator	-	rinse and repeat	---------------------------------------------------*///	print ("... ... ... create spheres, locate and parent\n");$ToriR = `floatSliderGrp -q -v fldSize`;string  $allObjects[];
$hr = `floatSliderGrp -q -v fldGeoHR`;select ("waveLoc_" + ($grpNum+1) + "_*");select -d ("waveLoc_" + ($grpNum+1) + "_Shape*");$x = 1;string  $obj;$allObjects = `ls -sl`;	for ( $obj in $allObjects ) 	{//		if ( `nodeType $obj` == "locator" ) //		{
			$nm = `torus -axis 0 1 0 -ch true 				-s 12 -nsp 12				-radius $ToriR -hr $hr`;
			rename $nm[0] ("evoTorus_" + ($grpNum+1) + "_" + $x);			rename $nm[1] ("make_evoTorus_" + ($grpNum+1) + "_" + $x);			pointConstraint  $obj ("evoTorus_" + ($grpNum+1) + "_" + $x);			select -r $obj ("evoTorus_" + ($grpNum+1) + "_" + $x);			parentConstraint -mo -weight 1;//		}		$x++;	}select -r ("evoTorus_" + ($grpNum+1) + "_*");select -d ("evoTorus_" + ($grpNum+1) + "_Shape*");select -d ("evoTorus_" + ($grpNum+1) + "_*_parentConstraint1");select -d ("evoTorus_" + ($grpNum+1) + "_*_pointConstraint1");$toriArray = `ls -sl`;$toriArraySize = `size($toriArray)`;select -cl;for($i=1;$i<=$toriArraySize;$i++){	if(`objExists "torusGrp"` == 0 && `objExists ("evoTorusGrp_" + ($grpNum+1))` == 0)	{		$torusGrp = `group -em`; 		xform -os -piv 0 0 0;		$evoTorusGrp = `group -em`; 		xform -os -piv 0 0 0;		parent ("evoTorus_" + ($grpNum+1) + "_" + $i) $evoTorusGrp;			parent $evoTorusGrp $torusGrp;		parent $torusGrp evoGrp;		rename $torusGrp "torusGrp";		rename $evoTorusGrp ("evoTorusGrp_" + ($grpNum+1));	}	else if(`objExists "torusGrp"` == 1 && `objExists ("evoTorusGrp_" + ($grpNum+1))` == 0)	{		$evoTorusGrp = `group -em`; 		xform -os -piv 0 0 0;		parent ("evoTorus_" + ($grpNum+1) + "_" + $i) $evoTorusGrp;			parent $evoTorusGrp torusGrp;			rename $evoTorusGrp ("evoTorusGrp_" + ($grpNum+1));	}	else	{		parent ("evoTorus_" + ($grpNum+1) + "_" + $i) ("evoTorusGrp_" + ($grpNum+1));	}}// updateAENotesStatus( "|evoCurveGroup01","notes");}

global proc evoPlaneCreate(int $grpNum){

/*	---------------------------------------------------		Part 3	-	Create a NURBS TORUS  	-	pointConstrain TORUS to WaveLocator	-	parent TORUS to WaveLocator	-	rinse and repeat	---------------------------------------------------*/$PlaneR = `floatSliderGrp -q -v fldSize`;string  $allObjects[];
$hr = `floatSliderGrp -q -v fldGeoHR`;select ("waveLoc_" + ($grpNum+1) + "_*");select -d ("waveLoc_" + ($grpNum+1) + "_Shape*");$x = 1;string  $obj;$allObjects = `ls -sl`;	for ( $obj in $allObjects ) 	{//		if ( `nodeType $obj` == "locator" ) //		{
			$nm = `nurbsPlane -p 0 0 0 -ax 0 1 0 -w ($PlaneR *2) -lr 1 -d 3 -u 1 -v 1 -ch 1`; 
			objectMoveCommand;
			rename $nm[0] ("evoPlane_" + ($grpNum+1) + "_" + $x);			rename $nm[1] ("make_evoPlane_" + ($grpNum+1) + "_" + $x);			pointConstraint  $obj ("evoPlane_" + ($grpNum+1) + "_" + $x);			select -r $obj ("evoPlane_" + ($grpNum+1) + "_" + $x);			parentConstraint -mo -skipRotate x -skipRotate y -skipRotate z -weight 1;//		}		$x++;	}select -r ("evoPlane_" + ($grpNum+1) + "_*");select -d ("evoPlane_" + ($grpNum+1) + "_Shape*");select -d ("evoPlane_" + ($grpNum+1) + "_*_parentConstraint1");select -d ("evoPlane_" + ($grpNum+1) + "_*_pointConstraint1");$planeArray = `ls -sl`;$planeArraySize = `size($planeArray)`;select -cl;for($i=1;$i<=$planeArraySize;$i++){	if(`objExists "planeGrp"` == 0 && `objExists ("evoPlaneGrp_" + ($grpNum+1))` == 0)	{		$planeGrp = `group -em`; 		xform -os -piv 0 0 0;		$evoPlaneGrp = `group -em`; 		xform -os -piv 0 0 0;		parent ("evoPlane_" + ($grpNum+1) + "_" + $i) $evoPlaneGrp;			parent $evoPlaneGrp $planeGrp;		parent $planeGrp evoGrp;		rename $planeGrp "planeGrp";		rename $evoPlaneGrp ("evoPlaneGrp_" + ($grpNum+1));	}	else if(`objExists "planeGrp"` == 1 && `objExists ("evoPlaneGrp_" + ($grpNum+1))` == 0)	{		$evoPlaneGrp = `group -em`; 		xform -os -piv 0 0 0;		parent ("evoPlane_" + ($grpNum+1) + "_" + $i) $evoPlaneGrp;			parent $evoPlaneGrp planeGrp;			rename $evoPlaneGrp ("evoPlaneGrp_" + ($grpNum+1));	}	else	{		parent ("evoPlane_" + ($grpNum+1) + "_" + $i) ("evoPlaneGrp_" + ($grpNum+1));	}}tt_aimConst;// updateAENotesStatus( "|evoCurveGroup01","notes");}


//----------------------------------------------------------------------//evo number field update//----------------------------------------------------------------------

global proc evoEdit()
{

//----------------------------------------------------------------------
//checks what kind of group is being edited (curve/sphere/torus/plane)
//enables or disables appropriate fields
//updates fields with current values
//----------------------------------------------------------------------

	int $evoNumArray[] = `textScrollList -q -sii torus_textList`;
	$evoNum = $evoNumArray[0];

	if(`objExists ("evoCurve_" + $evoNum)` == 1)
	{
		radioButtonGrp -e -sl 1 evoType;

		$hr = `getAttr ("rotateLoc_" + $evoNum + "_1.tx")`;
		$r = (`getAttr ("waveLoc_" + $evoNum + "_1.tx")`/$hr);
		floatFieldGrp -e -v1 $hr -v2 $r torusSpecGrp;

		$iArray = `listRelatives -c ("locatorGroup_" + $evoNum)`;
		$i = `size($iArray)`;
		$c = `getAttr ("centerLoc_" + $evoNum + "_2.ry")`;
		$loops = (($i * $c)/360)-.999;
		int $iLoop;
		$iLoop = $loops;
		intSliderGrp -e -v $iLoop fldLoops;

		floatSliderGrp -e -v $c fldRot;
		floatSliderGrp -e -en 0 fldSize;

		$anim = `keyframe -index 1 -q ("rotateLoc_" + $evoNum + "_1.rz")`;
		intSliderGrp -e -v $anim[0] fldCycle;

		$checkRevAnim = `keyframe -q -vc ("rotateLoc_" + $evoNum + "_1.rz")`;
		if($checkRevAnim[0] == 0)
		{
			checkBoxGrp -e -v1 0 ttRevAnim;
		}
		else
		{
			checkBoxGrp -e -v1 1 ttRevAnim;
		}

		button -e -en 1 tt_extrudeButton;
		floatSliderGrp -e -en 1 tt_extrudeRadius;

		if(`objExists ("taperSphereGrp_" + $evoNum)` == 1)
		{
			button -e -en 0 tt_extrudeButton;
			floatSliderGrp -e -en 1 tt_extrudeRadius;

			$taperList = `listRelatives -c ("taperSphereGrp_" + $evoNum)`;
			$taperNum = `size($taperList)`;
			intSliderGrp -e -v $taperNum torus_taperNum;

			frameLayout -e -cl 0 torus_frame;

			$jbCheck = `checkBoxGrp -q -v1 tt_JBcheck`;
			if($jbCheck == 0 )
			{
				window -e -h 1095 -w 480 lbs_scriptsWindow;
				tabLayout -e -h 1095 -w 480 winTab;
				
			}
			else 
			{
				window -e -h 1095 -w 795 lbs_scriptsWindow;
				tabLayout -e -h 1095 -w 795 winTab;
			}	


			$sphereList = `listRelatives -c ("taperSphereGrp_" + $evoNum + "_1")`;
			$sphereNum = `size($sphereList)`;
			intSliderGrp -e -v $sphereNum torus_sphereNum;

			$time = `currentTime -q`;
			currentTime 1;

			$taperSphereList = `listRelatives -c ("taperSphereGrp_" + $evoNum + "_1")`;
			$taperSphereNum = `size($taperSphereList)`;

			$torus_taperCurvePos = `getAttr ("taperSphereGrp_" + $evoNum + ".taperSphere_" + $evoNum + "_1_1")`;
			$curvePercent = ((`getAttr ("taperSphereGrp_" + $evoNum + ".taperSphere_" + $evoNum + "_1_" + $taperSphereNum)` - $torus_taperCurvePos) * $taperNum);
			
			floatSliderGrp -e -v $curvePercent torus_sphereSection;
			floatSliderGrp -e -v $torus_taperCurvePos torus_taperCurvePos;

			currentTime $time;
	
			$taperCycle = `keyframe -index 1 -q ("taperSphereGrp_" + $evoNum + ".taperSphere_" + $evoNum + "_1_1")`;
			floatSliderGrp -e -v $taperCycle[0] torus_sphereAnimCycle;

			$minR = `getAttr ("makeTaperSphere_" + $evoNum + "_1_1.radius")`;
			floatSliderGrp -e -v $minR torus_sphereMinRad;

			$taperSphereList = `listRelatives -c ("taperSphereGrp_" + $evoNum + "_1")`;
			$taperSphereNum = `size($taperSphereList)`;
			int $taperSphereCycle = $taperSphereNum/2;
			if($taperSphereNum % 2 != 0)
			{
				$taperSphereCycle = $taperSphereCycle + 1;
			}
			$maxR = `getAttr ("makeTaperSphere_" + $evoNum + "_1_" + $taperSphereCycle + ".radius")`;
			floatSliderGrp -e -v $maxR torus_sphereMaxRad;
		
		}
		else
		{
			//frameLayout -e -cl 1 torus_frame;
			//window -e -h 740 -w 480 lbs_scriptsWindow;
		}

		intSliderGrp -e -en 1 torus_taperNum;
		intSliderGrp -e -en 1 torus_sphereNum;
		floatSliderGrp -e -en 1 torus_sphereSection;
		floatSliderGrp -e -en 1 torus_sphereAnimCycle;
		floatSliderGrp -e -en 1 torus_sphereMinRad;
		floatSliderGrp -e -en 1 torus_sphereMaxRad;
		floatSliderGrp -e -en 1 torus_taperCenter;
		floatSliderGrp -e -en 1 torus_taperCurvePos;
		checkBoxGrp -e -en 0 tt_aimCheckBox;
	}

	else if(`objExists ("evoSphereGrp_" + $evoNum)` == 1)
	{
		button -e -en 0 tt_extrudeButton;
		floatSliderGrp -e -en 1 tt_extrudeRadius;

		radioButtonGrp -e -sl 2 evoType;

		$hr = `getAttr ("rotateLoc_" + $evoNum + "_1.tx")`;
		$r = (`getAttr ("waveLoc_" + $evoNum + "_1.tx")`/$hr);
		floatFieldGrp -e -v1 $hr -v2 $r torusSpecGrp;

		$iArray = `listRelatives -c ("locatorGroup_" + $evoNum)`;
		$i = `size($iArray)`;
		$c = `getAttr ("centerLoc_" + $evoNum + "_2.ry")`;
		$loops = (($i * $c)/360)-1;
		intSliderGrp -e -v $loops fldLoops;

		floatSliderGrp -e -v $c fldRot;
		floatSliderGrp -e -en 0 fldSize;

		$anim = `keyframe -index 1 -q ("rotateLoc_" + $evoNum + "_1.rz")`;
		intSliderGrp -e -v $anim[0] fldCycle;

		$checkRevAnim = `keyframe -q -vc ("rotateLoc_" + $evoNum + "_1.rz")`;
		if($checkRevAnim[0] == 0)
		{
			checkBoxGrp -e -v1 0 ttRevAnim;
		}
		else
		{
			checkBoxGrp -e -v1 1 ttRevAnim;
		}

		$sphereR = `getAttr ("make_evoSphere_" + $evoNum + "_1.r")`;
		floatSliderGrp -e -v $sphereR fldSize;

		intSliderGrp -e -en 0 torus_taperNum;
		intSliderGrp -e -en 0 torus_sphereNum;
		floatSliderGrp -e -en 0 torus_sphereSection;
		floatSliderGrp -e -en 0 torus_sphereAnimCycle;
		floatSliderGrp -e -en 0 torus_sphereMinRad;
		floatSliderGrp -e -en 0 torus_sphereMaxRad;
		checkBoxGrp -e -en 0 tt_aimCheckBox;
	}

	else if(`objExists ("evoTorusGrp_" + $evoNum)` == 1)
	{
		button -e -en 0 tt_extrudeButton;
		floatSliderGrp -e -en 1 tt_extrudeRadius;

		radioButtonGrp -e -sl 3 evoType;

		$hr = `getAttr ("rotateLoc_" + $evoNum + "_1.tx")`;
		$r = (`getAttr ("waveLoc_" + $evoNum + "_1.tx")`/$hr);
		floatFieldGrp -e -v1 $hr -v2 $r torusSpecGrp;

		$iArray = `listRelatives -c ("locatorGroup_" + $evoNum)`;
		$i = `size($iArray)`;
		$c = `getAttr ("centerLoc_" + $evoNum + "_2.ry")`;
		$loops = (($i * $c)/360)-1;
		intSliderGrp -e -v $loops fldLoops;

		floatSliderGrp -e -v $c fldRot;
		floatSliderGrp -e -en 0 fldSize;

		$torusHR = `getAttr ("make_evoTorus_" + $evoNum + "_1.hr")`;
		$torusRadius = `getAttr ("make_evoTorus_" + $evoNum + "_1.r")`;

		floatSliderGrp -e -v $torusHR fldGeoHR;
		floatSliderGrp -e -v $torusRadius fldSize;

		$anim = `keyframe -index 1 -q ("rotateLoc_" + $evoNum + "_1.rz")`;
		intSliderGrp -e -v $anim[0] fldCycle;

		$checkRevAnim = `keyframe -q -vc ("rotateLoc_" + $evoNum + "_1.rz")`;
		if($checkRevAnim[0] == 0)
		{
			checkBoxGrp -e -v1 0 ttRevAnim;
		}
		else
		{
			checkBoxGrp -e -v1 1 ttRevAnim;
		}

		intSliderGrp -e -en 0 torus_taperNum;
		intSliderGrp -e -en 0 torus_sphereNum;
		floatSliderGrp -e -en 0 torus_sphereSection;
		floatSliderGrp -e -en 0 torus_sphereAnimCycle;
		floatSliderGrp -e -en 0 torus_sphereMinRad;
		floatSliderGrp -e -en 0 torus_sphereMaxRad;
		checkBoxGrp -e -en 0 tt_aimCheckBox;
	}

	else if(`objExists ("evoPlaneGrp_" + $evoNum)` == 1)
	{
		button -e -en 0 tt_extrudeButton;
		floatSliderGrp -e -en 1 tt_extrudeRadius;

		radioButtonGrp -e -sl 4 evoType;

		$hr = `getAttr ("rotateLoc_" + $evoNum + "_1.tx")`;
		$r = (`getAttr ("waveLoc_" + $evoNum + "_1.tx")`/$hr);
		floatFieldGrp -e -v1 $hr -v2 $r torusSpecGrp;

		$iArray = `listRelatives -c ("locatorGroup_" + $evoNum)`;
		$i = `size($iArray)`;
		$c = `getAttr ("centerLoc_" + $evoNum + "_2.ry")`;
		$loops = (($i * $c)/360)-1;
		intSliderGrp -e -v $loops fldLoops;

		floatSliderGrp -e -v $c fldRot;
		floatSliderGrp -e -en 0 fldSize;

		if(`objExists ("evoPlane_" + $evoNum + "_1_aimConstraint1")` == 1)
		{
			checkBoxGrp -e -v1 1 tt_aimCheckBox;
		}
		else
		{
			checkBoxGrp -e -v1 0 tt_aimCheckBox;
		}

		$anim = `keyframe -index 1 -q ("rotateLoc_" + $evoNum + "_1.rz")`;
		intSliderGrp -e -v $anim[0] fldCycle;

		$checkRevAnim = `keyframe -q -vc ("rotateLoc_" + $evoNum + "_1.rz")`;
		if($checkRevAnim[0] == 0)
		{
			checkBoxGrp -e -v1 0 ttRevAnim;
		}
		else
		{
			checkBoxGrp -e -v1 1 ttRevAnim;
		}

		intSliderGrp -e -en 0 torus_taperNum;
		intSliderGrp -e -en 0 torus_sphereNum;
		floatSliderGrp -e -en 0 torus_sphereSection;
		floatSliderGrp -e -en 0 torus_sphereAnimCycle;
		floatSliderGrp -e -en 0 torus_sphereMinRad;
		floatSliderGrp -e -en 0 torus_sphereMaxRad;
		floatSliderGrp -e -en 0 torus_taperCenter;
		floatSliderGrp -e -en 0 torus_taperCurvePos;
		checkBoxGrp -e -en 1 tt_aimCheckBox;
	}

	else
	{
		warning("No Group " + $evoNum + "\n");
	}

	evoType();

}
//----------------------------------------------------------------------//update radius and HR//----------------------------------------------------------------------global proc radiusUpdate(){

//----------------------------------------------------------------------
//updates radius and height ratio of evo
//----------------------------------------------------------------------
$edit = `radioButtonGrp -q -sl editRadio`;int $evoNumArray[] = `textScrollList -q -sii torus_textList`;
$evoNum = $evoNumArray[0];$tRad = `floatFieldGrp -q -v1 torusSpecGrp`;$HR = `floatFieldGrp -q -v2 torusSpecGrp`;$WRad =  ($tRad*$HR);if($edit == 1 && $evoNum > 0)	{	//print("Radius: " + $tRad + "\n");	//print("HR: " + $HR + "\n");	//print("WRad: " + $WRad + "\n");

	setAttr -lock 0 ("locatorGroup_" + ($evoNum) + ".heightRatio");
	setAttr -lock 0 ("locatorGroup_" + ($evoNum) + ".radius");
	setAttr ("locatorGroup_" + ($evoNum) + ".heightRatio") $HR; 	setAttr ("locatorGroup_" + ($evoNum) + ".radius") $tRad;
	setAttr -lock 1 ("locatorGroup_" + ($evoNum) + ".heightRatio");
	setAttr -lock 1 ("locatorGroup_" + ($evoNum) + ".radius");	}}

//-----------------------------------------------------------------------------------------------------

proc jbEvoReorder(int $jbNum, int $evoNum, int $evoType){
/*	$array = `listRelatives -c ("JB_" + $jbNum + "_evoCurve_" + $evoNum)`;	$arraySize = `size($array)`;	string $evoName;		if($evoType == 0)	{		$evoName = "evoCurve_JB_";	}	for($i=0;$i<$arraySize;$i++)	{		while( $array[$i] != ( $evoName + $evoNum + "_shell_" + $i ))		{			reorder -relative -1 ($evoName + $evoNum + "_shell_" + $i);			$array = `listRelatives -c locatorGrp`;		}	}
*/}

//-----------------------------------------------------------------------------------------------------

proc evoPopulate(int $ttEvoJBTypeSel, int $ttDbl, int $evoNum, int $jbNum, int $shells[], int $evoType)
{
	int $newShells[] = {};
	string $evoSource;
	string $jbEvoName;
	$evoHR = `getAttr ("locatorGroup_" + $evoNum + ".heightRatio")`;
	$evoR = `getAttr ("locatorGroup_" + $evoNum + ".radius")`;
	print($evoType + " --evotype\n");

	int $curveNum;
	int $n;

	if($evoType == 0)
	{
		$evoSource = "evoCurve_";
		$jbEvoName = "evoCurve_";
	}
	else if($evoType == 1)
	{
		$evoSource = "evoSphereGrp_";
		$jbEvoName = "evoSphere_";
	}
	else if($evoType == 2)
	{
		$evoSource = "evoTorusGrp_";
		$jbEvoName = "evoTorus_";
	}
	else if($evoType == 3)
	{
		$evoSource = "evoPlaneGrp_";
		$jbEvoName = "evoPlane_";
	}
	else if($evoType == 4)
	{
		$evoSource = "evoExtrudeGrp_";
		$jbEvoName = "evoExtrude_";
	}
	else if($evoType == 5)
	{
		$evoSource = "taperSphereGrp_";
		$jbEvoName = "evoTaper_";
	}

	print("Evo Source: " + $evoSource + " :: JB Evo: " + $jbEvoName + "\n");

	//-----------------------------------------------
	//Connect Evo Curve/Geometry to JB Faces

	if($ttEvoJBTypeSel == 2)
	{
		for($a=0;$a<`size($shells)`;$a++)
		{
			if(`objExists ($jbEvoName + $evoNum + "_JB_" + $jbNum + "_shell_" + $shells[$a])` == 0)
			{
				$newShells[$a] = $shells[$a];
			}
		}

		$shellNum = `size($newShells)`;

		int $evoDup = 0;
		for($i=0;$i<$shellNum;$i++)
		{
			if($newShells[$i] == 0)
			{
				$evoDup = $evoDup + 8;
			}
			else
			{
				$evoDup = $evoDup + 64;
			}
		}

		string $evoArray[] = {};
		for($i=0;$i<$evoDup;$i++)
		{
			$evoInst = `instance ($evoSource + $evoNum)`;
			if($ttDbl == 2)
			{
				setAttr ($evoInst[0] + ".ty") ($evoHR*$evoR);
				move -r 0 (-1*($evoHR*$evoR)) 0 ($evoInst[0] + ".scalePivot") ($evoInst[0] + ".rotatePivot");

				$evoInstDbl = `instance $evoInst[0]`;
				setAttr ($evoInstDbl[0] + ".rz") 180;
				select -r $evoInst[0] $evoInstDbl[0];
				$evoInst[0] = `group`;
				xform -os -piv 0 0 0;
			}
			$evoArray[$i] = $evoInst[0];
		}

		$curveNum = 0;

		if(`objExists ("JB_" + $jbNum + "_" + $jbEvoName + $evoNum)` == 0)
		{
			$evoCurveGrp = `group -em`;
			xform -os -piv 0 0 0;
			parent $evoCurveGrp ("jitterbug_" + $jbNum + "_shell_group");
			rename $evoCurveGrp ("JB_" + $jbNum + "_" + $jbEvoName + $evoNum);
		}

		while($curveNum < (`size($evoArray)`))
		{
			for($i=0;$i<$shellNum;$i++)
			{
				if($newShells[$i] == 0)
				{
					string $crvGrp;
					select -cl;
					$crvGrp = `group -em`;

					for($n=1;$n<=8;$n++)
					{
						select -r ("group_" + $jbNum + "_shell_" + $i + "_face_" + $n) $evoArray[$curveNum];
						pointConstraint -offset 0 0 0 -weight 1;

						select -r ("group_" + $jbNum + "_shell_" + $i) $evoArray[$curveNum];
						aimConstraint -offset 0 0 0 -weight 1 -aimVector 0 1 0 -upVector 0 1 0 -worldUpType "vector" -worldUpVector 0 1 0;
				
						parent $evoArray[$curveNum] $crvGrp;
						rename $evoArray[$curveNum] ($jbEvoName + "JB_" + $jbNum + "_shell_" + $i + "_face_" + $n);
						$curveNum++;
						$curveCount = $curveNum;
					}

					parent $crvGrp ("JB_" + $jbNum + "_" + $jbEvoName + $evoNum);
					rename $crvGrp ($jbEvoName + $evoNum + "_JB_" + $jbNum + "_shell_" + $i);
				}
				else if($newShells[$i] != 0)
				{
					$shellGrp = `group -em`;
					xform -os -piv 0 0 0;
					parent $shellGrp ("JB_" + $jbNum + "_" + $jbEvoName + $evoNum);	

					string $crvGrp;		
	
					for($n=1;$n<=8;$n++)
					{
						select -cl;
						$crvGrp = `group -em`;
					
						for($e=1;$e<=8;$e++)
						{
							select -r ("group_" + $jbNum + "_shell_" + $newShells[$i] + "_arm_" + $n + "_face_" + $e) $evoArray[$curveNum];
							pointConstraint -offset 0 0 0 -weight 1;

							select -r ("group_" + $jbNum + "_shell_" + $newShells[$i] + "_arm_" + $n) $evoArray[$curveNum];
							aimConstraint -offset 0 0 0 -weight 1 -aimVector 0 1 0 -upVector 0 1 0 -worldUpType "vector" -worldUpVector 0 1 0;
						
							parent $evoArray[$curveNum] $crvGrp;
							if($ttDbl == 2)
							{
								$dblCrvList = `listRelatives -c $evoArray[$curveNum]`;
								rename $dblCrvList[0] ($jbEvoName + "JB_" + $jbNum + "_shell_" + $newShells[$i] + "_arm_" + $n + "_face_" + $e + "_crv1");
								rename $dblCrvList[1] ($jbEvoName + "JB_" + $jbNum + "_shell_" + $newShells[$i] + "_arm_" + $n + "_face_" + $e + "_crv2");
							}
							rename $evoArray[$curveNum] ($jbEvoName + "JB_" + $jbNum + "_shell_" + $newShells[$i] + "_arm_" + $n + "_face_" + $e);
							$curveNum++;
							$curveCount = $curveNum;
						}
					
						parent $crvGrp $shellGrp;
						rename $crvGrp ($jbEvoName + "JB_" + $jbNum + "_shell_" + $newShells[$i] + "_arm_" + $n);
					}
					rename $shellGrp ($jbEvoName + $evoNum + "_JB_" + $jbNum + "_shell_" + $newShells[$i]);
				}
			}
		
			if(`objExists("evoCurve_" + $evoNum)` == 1)
			{
				$curveParent = `listRelatives -p ("evoCurve_" + $evoNum)`;
				if($curveParent[0] != "curveGrp")
				{
					parent ("evoCurve_" + $evoNum) curveGrp;
				}
			}
		}
	}

	//----------------------------------
	//Connect Evo Curve/Geometry to JB Centers

	else
	{
		for($a=0;$a<`size($shells)`;$a++)
		{
			if(`objExists ($jbEvoName + $evoNum + "_JB_" + $jbNum + "_shell_" + $shells[$a])` == 0)
			{
				$newShells[$a] = $shells[$a];
			}
		}

		$shellNum = `size($newShells)`;

		int $evoDup = 0;
		for($i=0;$i<$shellNum;$i++)
		{
			if($newShells[$i] == 0)
			{
				$evoDup = $evoDup + 1;
			}
			else
			{
				$evoDup = $evoDup + 8;
			}
		}

		print("duplicate evo " + $evoDup + " time(s)\n");

		string $evoArray[] = {};
		for($i=0;$i<$evoDup;$i++)
		{
			$evoInst = `instance ($evoSource + $evoNum)`;
			if($ttDbl == 2)
			{
				setAttr ($evoInst[0] + ".ty") ($evoHR*$evoR);
				move -r 0 (-1*($evoHR*$evoR)) 0 ($evoInst[0] + ".scalePivot") ($evoInst[0] + ".rotatePivot");

				$evoInstDbl = `instance $evoInst[0]`;
				setAttr ($evoInstDbl[0] + ".rz") 180;
				select -r $evoInst[0] $evoInstDbl[0];
				$evoInst[0] = `group`;
				xform -os -piv 0 0 0;
			}
			$evoArray[$i] = $evoInst[0];
		}

		if(`objExists ("JB_" + $jbNum + "_" + $jbEvoName + $evoNum)` == 0)
		{
			$evoCurveGrp = `group -em`;
			xform -os -piv 0 0 0;
			parent $evoCurveGrp ("jitterbug_" + $jbNum + "_shell_group");
			rename $evoCurveGrp ("JB_" + $jbNum + "_" + $jbEvoName + $evoNum);
		}

		while($curveNum < (`size($evoArray)`))
		{
			for($i=0;$i<$shellNum;$i++)
			{
				//---------------------------------------
				//constrain evo instance to center jitterbug

				if($newShells[$i] == 0)
				{
					string $crvGrp;
					select -cl;
					$crvGrp = `group -em`;

					select -r ("group_" + $jbNum + "_shell_" + $i) $evoArray[$curveNum];
					pointConstraint -offset 0 0 0 -weight 1;

					parent $evoArray[$curveNum] $crvGrp;
					rename $evoArray[$curveNum] ($jbEvoName + "JB_" + $jbNum + "_shell_" + $i + "_face_" + $n);
					$curveNum++;
					$curveCount = $curveNum;
					
					parent $crvGrp ("JB_" + $jbNum + "_" + $jbEvoName + $evoNum);
					rename $crvGrp ($jbEvoName + $evoNum + "_JB_" + $jbNum + "_shell_" + $i);
				}
				//---------------------------------------------
				//constrain 8 evo instances to jitterbug arms

				else if($newShells[$i] != 0)
				{
					$shellGrp = `group -em`;
					xform -os -piv 0 0 0;
					parent $shellGrp ("JB_" + $jbNum + "_" + $jbEvoName + $evoNum);	

					string $crvGrp;		
	
					for($n=1;$n<=8;$n++)
					{
						select -cl;
						$crvGrp = `group -em`;
					
						select -r ("group_" + $jbNum + "_shell_" + $newShells[$i] + "_arm_" + $n) $evoArray[$curveNum];
						pointConstraint -offset 0 0 0 -weight 1;

						parent $evoArray[$curveNum] $crvGrp;
						if($ttDbl == 2)
						{
							$dblCrvList = `listRelatives -c $evoArray[$curveNum]`;
							rename $dblCrvList[0] ($jbEvoName + "JB_" + $jbNum + "_shell_" + $newShells[$i] + "_arm_" + $n + "_crv1");
							rename $dblCrvList[1] ($jbEvoName + "JB_" + $jbNum + "_shell_" + $newShells[$i] + "_arm_" + $n + "_crv2");
						}
						rename $evoArray[$curveNum] ($jbEvoName + "JB_" + $jbNum + "_shell_" + $newShells[$i] + "_arm_" + $n);
						$curveNum++;
						$curveCount = $curveNum;
					
						parent $crvGrp $shellGrp;
						rename $crvGrp ($jbEvoName + "JB_" + $jbNum + "_shell_" + $newShells[$i] + "_arm_" + $n);
					}
					rename $shellGrp ($jbEvoName + $evoNum + "_JB_" + $jbNum + "_shell_" + $newShells[$i]);
				}
			}
		}
	}

	//This could be removed???
	//jbEvoReorder($jbNum,$evoNum,0);	
}
//----------------------------------------------------------------------//update number of loops//----------------------------------------------------------------------global proc evoUpdate()
{
//----------------------------------------------------------------------
//if loops or rotation is changed curve will need to be rebuilt
//this deletes current group and reruns building procedures
//----------------------------------------------------------------------//----------------------------------------------------------------------
//if loops or rotation is changed curve will need to be rebuilt
//this deletes current group and reruns building procedures
//----------------------------------------------------------------------
	$ttEvoJBTypeSel = `radioButtonGrp -q -sl tt_evoJBConnSel`;
	$ttDbl = `radioButtonGrp -q -sl tt_dblRadio`;	$edit = `radioButtonGrp -q -sl editRadio`;	int $evoNumArray[] = `textScrollList -q -sii torus_textList`;
	$evoNum = $evoNumArray[0];	
	int $taperEx = 0;

	int $reconnect = 0;	if($edit == 1 && $evoNum > 0)	{

		$locXT = `xform -q -t ("locatorGroup_" + $evoNum)`;
		$locXR = `xform -q -ro ("locatorGroup_" + $evoNum)`;
		$locXS = `xform -q -s -r ("locatorGroup_" + $evoNum)`;

		float $tRad = `floatFieldGrp -query -v1 torusSpecGrp`;		float $HR = `floatFieldGrp -query -v2 torusSpecGrp`;		int $loops = `intSliderGrp -query -v fldLoops`;		float $dRot = `floatSliderGrp -query -v fldRot`;		int $Cycle = `intSliderGrp -query -v fldCycle`;
		select -r ("locatorGroup_" + $evoNum);		doDelete;

		//FIND OUT WHICH JITTERBUG GROUPS AND SHELLS OF JITTERBUG HAVE EVOCURVES
		//DELETE OF EVOCURVES CONNECTED TO JITTERBUG FACES

		int $evoShellSize = 0;
		int $evoShellNumbers[] = {};		if(`objExists ("evoCurve_" + $evoNum)` == 1)		{
			if(`objExists ("taperSphereGrp_" + $evoNum)` == 1)
			{
				//delete ("taperSphereGrp_" + $evoNum);
				$taperEx = 1;
			}

			delete ("evoCurve_" + $evoNum);
			evoCurve($tRad, $HR, $loops, $dRot, $Cycle);

			if($taperEx == 1)
			{
				textScrollList -e -sii $evoNum torus_textList;
				torusTaperBeads;
			}


			if(`objExists jitterbug_LOCKED_groups` == 1)
			{
				$jbNumList = `listRelatives -c jitterbug_LOCKED_groups`;
				$jbNum = `size($jbNumList)`;

				for($a=1;$a<=$jbNum;$a++)
				{
					$shellList = `listRelatives -c ("jitterbug_" + $a + "_shell_group")`;
					for($b=0;$b<`size($shellList)`;$b++)
					{
						if($shellList[$b] == ("JB_" + $a + "_evoCurve_" + $evoNum))
						{
							$evoShell = `listRelatives -c ("JB_" + $a + "_evoCurve_" + $evoNum)`;

							for($c=0;$c<`size($evoShell)`;$c++)
							{
								int $d = 0;
								while($evoShell[$c] != ("evoCurve_" + $evoNum + "_JB_" + $a + "_shell_" + $d))
								{
									$d++;
								}
								$evoShellNumbers[$c] = $d;
							}
							$evoShellSize = `size($evoShellNumbers)`;
							delete ("JB_" + $a + "_evoCurve_" + $evoNum);

							evoPopulate($ttEvoJBTypeSel, $ttDbl, $evoNum, $a, $evoShellNumbers, 0);
						}
					}
					for($b=0;$b<`size($shellList)`;$b++)
					{
						if($shellList[$b] == ("JB_" + $a + "_evoTaper_" + $evoNum))
						{
							$evoShell = `listRelatives -c ("JB_" + $a + "_evoTaper_" + $evoNum)`;

							for($c=0;$c<`size($evoShell)`;$c++)
							{
								int $d = 0;
								while($evoShell[$c] != ("evoTaper_" + $evoNum + "_JB_" + $a + "_shell_" + $d))
								{
									$d++;
								}
								$evoShellNumbers[$c] = $d;
							}
							$evoShellSize = `size($evoShellNumbers)`;
							delete ("JB_" + $a + "_evoTaper_" + $evoNum);

							evoPopulate($ttEvoJBTypeSel, $ttDbl, $evoNum, $a, $evoShellNumbers, 5);
						}
					}
				}
			}
		}		else if(`objExists ("evoSphereGrp_" + $evoNum)` == 1)		{			select -r ("evoSphereGrp_" + $evoNum);			doDelete;			radioButtonGrp -e -sl 2 evoType;
			evoCurve($tRad, $HR, $loops, $dRot, $Cycle);		}
		else if(`objExists ("evoTorusGrp_" + $evoNum)` == 1)		{			select -r ("evoTorusGrp_" + $evoNum);			doDelete;			radioButtonGrp -e -sl 3 evoType;
			evoCurve($tRad, $HR, $loops, $dRot, $Cycle);		}
		else if(`objExists ("evoPlaneGrp_" + $evoNum)` == 1)		{			select -r ("evoPlaneGrp_" + $evoNum);			doDelete;			radioButtonGrp -e -sl 4 evoType;
			evoCurve($tRad, $HR, $loops, $dRot, $Cycle);		}		
//----------------------------------------------------------------------//reorder groups in locatorGrp and curveGrp//to be sequential//----------------------------------------------------------------------		$array = `listRelatives -c locatorGrp`;		$arraySize = `size($array)`;		for($i=1;$i<=$arraySize;$i++)		{			while( $array[ ($i-1) ] != ("locatorGroup_" + $i))			{				reorder -relative -1 ("locatorGroup_" + $i);				$array = `listRelatives -c locatorGrp`;			}		}		if(`objExists curveGrp` == 1)		{			int $curve[] = {};			for($i=1;$i<=$arraySize;$i++)			{
				if(`objExists ("evoCurve_" + $i)` == 1)				{					$curveSize = `size($curve)`;					$curve[$curveSize] = $i;				}			}						$curveGrp = `listRelatives -c curveGrp`;
			$curveSize = `size($curve)`;
			for($i=1;$i<=$curveSize;$i++)			{				while( $curveGrp[ ($i-1) ] != ("evoCurve_" + $curve[($i-1)]) )				{					reorder -relative -1 ("evoCurve_" + $curve[($i-1)]);					$curveGrp = `listRelatives -c curveGrp`;				}			}		}		if(`objExists sphereGrp` == 1)		{
			int $sphere[] = {};			for($i=1;$i<=$arraySize;$i++)			{
				if(`objExists ("evoSphereGrp_" + $i)` == 1)				{					$sphereSize = `size($sphere)`;					$sphere[$sphereSize] = $i;				}			}						$sphereGrp = `listRelatives -c sphereGrp`;
			$sphereSize = `size($sphere)`;
			for($i=1;$i<=$sphereSize;$i++)			{				while( $sphereGrp[ ($i-1) ] != ("evoSphereGrp_" + $sphere[($i-1)]) )				{					reorder -relative -1 ("evoSphereGrp_" + $sphere[($i-1)]);					$sphereGrp = `listRelatives -c sphereGrp`;				}			}		}

		if(`objExists torusGrp` == 1)		{
			int $torus[] = {};			for($i=1;$i<=$arraySize;$i++)			{
				if(`objExists ("evoTorusGrp_" + $i)` == 1)				{					$torusSize = `size($torus)`;					$torus[$torusSize] = $i;				}			}						$torusGrp = `listRelatives -c torusGrp`;
			$torusSize = `size($torus)`;
			for($i=1;$i<=$torusSize;$i++)			{				while( $torusGrp[ ($i-1) ] != ("evoTorusGrp_" + $torus[($i-1)]) )				{					reorder -relative -1 ("evoTorusGrp_" + $torus[($i-1)]);					$torusGrp = `listRelatives -c torusGrp`;				}			}		}

		xform -t $locXT[0] $locXT[1] $locXT[2] ("locatorGroup_" + $evoNum);
		xform -ro $locXR[0] $locXR[1] $locXR[2] ("locatorGroup_" + $evoNum);
		xform -s $locXS[0] $locXS[1] $locXS	[2] ("locatorGroup_" + $evoNum);
		textScrollList -e -sii $evoNum torus_textList;
		select -r ("locatorGroup_" + $evoNum);	}}

//----------------------------------------------------------------------//update geometry radius
//----------------------------------------------------------------------

global proc geometryUpdate()
{
	int $evoNumArray[] = `textScrollList -q -sii torus_textList`;
	$evoNum = $evoNumArray[0];	$edit = `radioButtonGrp -q -sl editRadio`;
	$size = `floatSliderGrp -q -v fldSize`;
	$hr = `floatSliderGrp -q -v fldGeoHR`;

	if($edit == 1 && $evoNum > 0)
	{
		if(`objExists ("evoSphereGrp_" + $evoNum)` == 1)
		{
			$sphereArray = `listRelatives -c ("evoSphereGrp_" + $evoNum)`;
			$sphereArraySize = `size($sphereArray)`;

			for($i=0;$i<$sphereArraySize;$i++)
			{
				setAttr ("make_evoSphere_" + $evoNum + "_" + ($i+1) + ".radius") $size;
			}
		}
		else if(`objExists ("evoTorusGrp_" + $evoNum)` == 1)
		{
			$torusArray = `listRelatives -c ("evoTorusGrp_" + $evoNum)`;
			$torusArraySize = `size($torusArray)`;

			for($i=0;$i<$torusArraySize;$i++)
			{
				setAttr ("make_evoTorus_" + $evoNum + "_" + ($i+1) + ".radius") $size;
				setAttr ("make_evoTorus_" + $evoNum + "_" + ($i+1) + ".hr") $hr;
			}
		}
		else if(`objExists ("evoPlaneGrp_" + $evoNum)` == 1)
		{
			$planeArray = `listRelatives -c ("evoPlaneGrp_" + $evoNum)`;
			$planeArraySize = `size($planeArray)`;

			for($i=0;$i<$planeArraySize;$i++)
			{
				setAttr ("make_evoPlane_" + $evoNum + "_" + ($i+1) + ".width") $size;
			}
		}
	}
}//----------------------------------------------------------------------//update animation cycle//----------------------------------------------------------------------global proc animUpdate()
{	int $evoNumArray[] = `textScrollList -q -sii torus_textList`;
	$evoNum = $evoNumArray[0];	$edit = `radioButtonGrp -q -sl editRadio`;		$speed = `intSliderGrp -q -v fldCycle`;
	int $revCheck = `checkBoxGrp -q -v1 ttRevAnim`; 	
	if($edit == 1 && $evoNum != 0)
	{
		CBdeleteConnection ("rotateLoc_" + $evoNum + "_1.rz");		tt_revAnim( $evoNum, $revCheck, $speed );
	}}//----------------------------------------------------------------------//create/edit radio button//----------------------------------------------------------------------global proc editCheck(){	$edit = `radioButtonGrp -q -sl editRadio`;		//print("edit mode selected: " + $edit + "\n");		if($edit == 1)	{		button -e -en 0 evoCurveButton;		//print("edit mode" + "\n");	}	else	{		button -e -en 1 evoCurveButton;
		textScrollList -e -da torus_textList;		//print("create mode" + "\n");

		intSliderGrp -e -en 0 torus_taperNum;
		intSliderGrp -e -en 0 torus_sphereNum;
		floatSliderGrp -e -en 0 torus_sphereSection;
		floatSliderGrp -e -en 0 torus_sphereAnimCycle;
		floatSliderGrp -e -en 0 torus_sphereMinRad;
		floatSliderGrp -e -en 0 torus_sphereMaxRad;
		floatSliderGrp -e -en 0 torus_taperCenter;
		floatSliderGrp -e -en 0 torus_taperCurvePos;	}}//----------------------------------------------------------------------//reset torus toolkit creation settings//----------------------------------------------------------------------global proc resetSettings(){	floatFieldGrp -e -v1 10.00 -v2 0.90 torusSpecGrp;	intSliderGrp -e -v 2 fldLoops;	floatSliderGrp -e -v 10 fldRot;	intSliderGrp -e -v 100 fldCycle;	floatSliderGrp -e -v 1 fldSize;

	$edit = `radioButtonGrp -q -sl editRadio`;
	if($edit == 1&& `objExists evoGrp` == 1)
	{
		evoUpdate();
		radiusUpdate();
		evoEdit();
		geometryUpdate();
		animUpdate();
	}}

global proc evoType()
{

//----------------------------------------------------------------------
//enable or disable fields depending on type of evolute
//----------------------------------------------------------------------

	$type = `radioButtonGrp -q -sl evoType`;
	if($type == 1)
	{
		floatSliderGrp -e -en 0 fldSize;
		floatSliderGrp -e -en 0 fldGeoHR;
		checkBoxGrp -e -en 0 tt_aimCheckBox;
	}
	else if($type == 2)
	{
		floatSliderGrp -e -en 1 fldSize;
		floatSliderGrp -e -en 0 fldGeoHR;
		checkBoxGrp -e -en 0 tt_aimCheckBox;
	}
	else if($type == 3)
	{
		floatSliderGrp -e -en 1 fldSize;
		floatSliderGrp -e -en 1 fldGeoHR;
		checkBoxGrp -e -en 0 tt_aimCheckBox;
	}
	else if($type == 4)
	{
		floatSliderGrp -e -en 1 fldSize;
		floatSliderGrp -e -en 0 fldGeoHR;
		checkBoxGrp -e -en 1 tt_aimCheckBox;
	}
}/*------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/global proc string evoBuild (float $tRad, float $HR,int $NumLoops, float $CentRot, float $speed) {	//	// 	Evolute Torus Build cook-book	//	//	created by Goa Lobaugh and Casey Pyke	//	//	//	$NumLoops = number of "laps" around torus before reconnecting	//	//	$CentRot = degree of rotation about the center. 	//				Defined by USER (spacing between nodes)	//	$AxisRot	= degree of rotation about the torus-core	//				defined by Number of Loops * 360 / Iterations	//	$speed = number of frames for 1 full 360 turn of locator	//			= suggest 100 frames/revolution	// variables & declarations	float $AxisRot;	float $i;	float $x = 1;	float $CurrentRot;	//	formulas	$i = (($NumLoops + 1) * 360 / $CentRot);	$AxisRot = $NumLoops * 360/($i);	float $WRad;	$WRad =  ($tRad*$HR) + $tRad;	//print ("Iterations: "+ $i + "\n");	//print ("Axis Rotation: " + $AxisRot + "\n");	spaceLocator -p 0 0 0;	rename "CenterLocator1" ;	setAttr .localScaleX .1;	setAttr .localScaleY .1;	setAttr .localScaleZ .1;	spaceLocator -p $tRad 0 0;	CenterPivot;	rename "RotateLocator1";	setAttr .localScaleX .1;	setAttr .localScaleY .1;	setAttr .localScaleZ .1;	spaceLocator -p $WRad 0 0;	CenterPivot;	rename "WaveLocator1";	setAttr .localScaleX .7;	setAttr .localScaleY .7;	setAttr .localScaleZ .7;	parent WaveLocator1 RotateLocator1;	parent RotateLocator1 CenterLocator1 ;	select CenterLocator1;	do	
	{		duplicate -rr -renameChildren; rotate -r 0 $CentRot 0;  		pickWalk -d down;		pickWalk -d right;		rotate -r 0 0 $AxisRot;		pickWalk -d left;		pickWalk -d up;		$x ++;	}	while ($x < $i);	$x = 2;	$i ++;	/*		part 2		setup animation keyframes, and setDrivenKeys for other nodes	*/	//	setup the initial keyframes for RotateLocator1		currentTime 1;	setAttr "RotateLocator1.rotateZ" 0;	setKeyframe "RotateLocator1.rz";	currentTime $speed ;	setAttr "RotateLocator1.rotateZ" 360;	setKeyframe "RotateLocator1.rz";	currentTime 1;	//	next SetDriven keys for all other RotateLocators to RotateLocator1	do	
	{		setAttr   "RotateLocator1.rotate" -type "double3" 0 0 0;		$CurrentRot = getAttr ("RotateLocator" + $x + ". rotateZ");		setDrivenKeyframe -currentDriver RotateLocator1.rotateZ ("RotateLocator" + $x + ".rotateZ");		setAttr   RotateLocator1.rotateZ 360;		$CurrentRot = $CurrentRot + 360;		setAttr -k 0 ("RotateLocator" + $x + ".rotateZ") $CurrentRot;		setDrivenKeyframe -currentDriver RotateLocator1.rotateZ ("RotateLocator" + $x + ".rotateZ");		$x ++;	}	while ($x < $i);	// 	cleanup the offending animation nodes 	//print ("select and delect  offending nodes \n");	select -r  RotateLocator1_rotateZ ;	delete;	//	setup the initial keyframes for RotateLocator1	currentTime 1;	setAttr "RotateLocator1.rotateZ" 0;	setKeyframe "RotateLocator1.rz";	currentTime $speed ;	setAttr "RotateLocator1.rotateZ" 360;	setKeyframe "RotateLocator1.rz";	currentTime 1;	//print ("now for the last bit... \n");	selectKey -add -k -t 100 RotateLocator1_rotateZ ;
		setInfinity -poi cycle;
		return "done";}/*	NOTES	NOTES	NOTES	NOTES	NOTES	NOTES	NOTES	 	Starting point is: NUMBER OF LOOPS around the torus			Torus Pattern Gray = 2 loops pass through center								= 3 nodes around the torus-core								= 3 laps around the center	2 loops = 1080 degrees around circumference (3 x 360)	@ 10 degrees/turn, 1080 = 108 iterations ($i) 	2 loops 	= 2 rotations about the torus core				= 720 degrees about the torus core				= 720 / 108 iterations = 6.666 degrees	108 	=  		3 					* 	36	#reps  	=   numNodes/Circle    	*   	numCircles*/

//------------------------------------------------------------
//------------------------------------------------------------
//
//------------------------------------------------------------
//------------------------------------------------------------

global proc torus_updateTextList()
{
	if(`objExists evoGrp` == 1)	{		$locArray = `listRelatives -c locatorGrp`;		$locNum = `size($locArray)`;		textScrollList -e -ra torus_textList;		for($i=1;$i<=$locNum;$i++)		{			if(`objExists ("evoCurve_" + $i)` == 1)				{
				if(`objExists ("taperSphereGrp_" + $i)` == 1)
				{
					textScrollList -e -append ("  ---         " + "Group " + $i + " ( Curve )" + "-taper---") torus_textList;
				}
				else if(`objExists ("evoExtrudeGrp_" + $i)` == 1)
				{
					textScrollList -e -append ("  ---         " + "Group " + $i + " ( Curve )" + "-extrude-") torus_textList;
				}
				else
				{
					textScrollList -e -append ("  ---         " + "Group " + $i + " ( Curve )" + "          ---") torus_textList;
				}
							}			else if(`objExists ("evoSphereGrp_" + $i)` == 1)				{				textScrollList -e -append ("  ---         " + "Group " + $i + " ( Sphere )" + "         ---") torus_textList;			}			else if(`objExists ("evoTorusGrp_" + $i)` == 1)				{				textScrollList -e -append ("  ---         " + "Group " + $i + " ( Torus )" + "          ---") torus_textList;			}
			else if(`objExists ("evoPlaneGrp_" + $i)` == 1)				{				textScrollList -e -append ("  ---         " + "Group " + $i + " ( Plane )" + "          ---") torus_textList;			}		}	}
	else
	{
		textScrollList -e -ra torus_textList;
	}
}

//------------------------------------------------------------
//------------------------------------------------------------
//
//------------------------------------------------------------
//------------------------------------------------------------

global proc torus_editTextList()
{
	int $grpSel[] = `textScrollList -q -sii torus_textList`;

	if($grpSel[0] != 0)
	{
		radioButtonGrp -e -sl 1 editRadio;
		button -e -en 0 evoCurveButton;
		evoEdit;
		select -r ("locatorGroup_" + $grpSel[0]);
	}
	else
	{
		radioButtonGrp -e -sl 2 editRadio;
		button -e -en 1 evoCurveButton;

		button -e -en 0 tt_extrudeButton;
		floatSliderGrp -e -en 0 tt_extrudeRadius;
		intSliderGrp -e -en 0 torus_taperNum;
		intSliderGrp -e -en 0 torus_sphereNum;
		floatSliderGrp -e -en 0 torus_sphereSection;
		floatSliderGrp -e -en 0 torus_sphereAnimCycle;
		floatSliderGrp -e -en 0 torus_sphereMinRad;
		floatSliderGrp -e -en 0 torus_sphereMaxRad;
		floatSliderGrp -e -en 0 torus_taperCenter;
		floatSliderGrp -e -en 0 torus_taperCurvePos;
	}
}

//-----------------------------------------------------------------------------------------------------

proc evoTaperDelete(int $evoNum)
{
	int $evoShellNumbers[] = {};

	if(`objExists ("taperSphereGrp_" + $evoNum)` == 1)	{
		delete ("taperSphereGrp_" + $evoNum);
		$taperSphereChld = `listRelatives -c taperSphereGrp`;

		if(`size($taperSphereChld)`==0)
		{
			delete taperSphereGrp;
		}

		if(`objExists jitterbug_LOCKED_groups` == 1)
		{
			$jbNumList = `listRelatives -c jitterbug_LOCKED_groups`;
			$jbNum = `size($jbNumList)`;

			for($a=1;$a<=$jbNum;$a++)
			{
				$shellList = `listRelatives -c ("jitterbug_" + $a + "_shell_group")`;
				for($b=0;$b<`size($shellList)`;$b++)
				{
					if($shellList[$b] == ("JB_" + $a + "_evoTaper_" + $evoNum))
					{
						//print("JB_" + $a + "_evoTaper_" + $evoNum + " exists!!!" + "\n");
						$evoShell = `listRelatives -c ("JB_" + $a + "_evoTaper_" + $evoNum)`;
				
						for($c=0;$c<`size($evoShell)`;$c++)
						{
							int $d = 0;
							while($evoShell[$c] != ("evoTaper_" + $evoNum + "_JB_" + $a + "_shell_" + $d))
							{
								$d++;
							}
							$evoShellNumbers[$c] = $d;
						}
						$evoShellSize = `size($evoShellNumbers)`;
						delete ("JB_" + $a + "_evoTaper_" + $evoNum);

						$jbEvoNum = $a;
					}
				}
			}
		}

	}

}

//-----------------------------------------------------------------------------------------------------

proc evoTaperCreate( float $taperNum, float $sphereNum, float $section, float $animCycle, float $minRad, float $maxRad, int $evoNum, float $taperCenter, float $taperCurvePos)
{


	select -r ("evoCurve_" + $evoNum);
	$curve = `ls -sl`;
	$taperNum = $taperNum + .000;
	$sphereNum = $sphereNum + .000;
	$section = $section + .000;
	$taperCenter = $taperCenter + .000;
	float $taperSection = $section/$taperNum;
	float $taperCenterVal = $taperSection * $taperCenter;

	float $taperLowVal = 0;
	float $taperHighVal = 0;

	float $midSphere = $sphereNum/2;
	$even = 1;

	if($sphereNum%2 != 0)
	{
		$midSphere = $midSphere + .5;
		$even = 0;
	}

	if($sphereNum>2)
	{
		$taperLowVal = $taperCenterVal/($midSphere-1);
	}
	if($sphereNum == 2)
	{
		$taperHighVal = ($taperSection-$taperCenterVal)/2;
	}
	else if($sphereNum>2)
	{
		if($even==1)
		{
			$taperHighVal = ($taperSection-$taperCenterVal)/$midSphere;
		}
		else if($even==0)
		{
			$taperHighVal = ($taperSection-$taperCenterVal)/($midSphere-1);
		}
	}
	float $taperHighADJUST = $taperCenterVal;

	//FIND OUT WHICH JITTERBUG GROUPS AND SHELLS OF JITTERBUG HAVE EVOTAPERS
	//DELETE OF EVOTAPERS CONNECTED TO JITTERBUG FACES
		
	int $evoShellSize = 0;
	int $evoShellNumbers[] = {};
	int $jbEvoNum = 0;
	int $jbNum = 0;
	evoTaperDelete($evoNum);
	
	if(`size($curve)` == 1)
	{
		$sphereGrp = `group -em`;
		xform -os -piv 0 0 0;
		float $i;
		float $e;
		float $a;
		int $sphereINC=0;

		string $sphereList[] = {};
		float $pathAnimVal[] = {};

		for($a=0;$a<$midSphere;$a++)
		{
			$pathAnimVal[$sphereINC] = $taperLowVal * $a;
			$sphereINC++;
		}
		for($b=1;$b<($midSphere+$even);$b++)
		{
			$taperHighADJUST = $taperHighADJUST + $taperHighVal;
			$pathAnimVal[$sphereINC] = $taperHighADJUST;
			$sphereINC++;
		}
	
		for($i=0.00;$i<$taperNum;$i++)
		{
			$taperGrp = `group -em`;
			xform -os -piv 0 0 0;
			int $sphereINC=0;

			for($e=0.00;$e<$sphereNum;$e++)
			{
				$titleSphere = `sphere -p 0 0 0 -ax 0 1 0 -ssw 0 -esw 360 -r 1 -d 3 -ut 0 -tol 0.01 -s 8 -nsp 4 -ch 1`;
				objectMoveCommand;
				select -r $titleSphere[0] $curve;
				$path = `pathAnimation -fractionMode true -follow true -bank true -startTimeU 1 -endTimeU 100`;

				parent $titleSphere[0] $taperGrp;
				addAttr -ln ("taperSphere_" + $evoNum + "_" + ($i+1) + "_" + ($e+1))  -at double  $sphereGrp;
				setAttr -e-keyable true ($sphereGrp + ".taperSphere_" + $evoNum + "_" + ($i+1) + "_" + ($e+1));
	
				setKeyframe -t 1 -v (( $pathAnimVal[$sphereINC] + ($i/$taperNum)) + $taperCurvePos) ($sphereGrp + ".taperSphere_" + $evoNum + "_" + ($i+1) + "_" + ($e+1));
					
				setKeyframe -t $animCycle -v ((( $pathAnimVal[$sphereINC] + ($i/$taperNum)) +1 ) + $taperCurvePos ) ($sphereGrp + ".taperSphere_" + $evoNum + "_" + ($i+1) + "_" + ($e+1));
				
				setInfinity -poi cycle ($sphereGrp + ".taperSphere_" + $evoNum + "_" + ($i+1) + "_" + ($e+1));			

				$condition = `shadingNode -asUtility condition`;
				$plusMinus = `shadingNode -asUtility plusMinusAverage`;

				connectAttr -f ($condition + ".firstTerm") ($plusMinus + ".input1D[0]");
				connectAttr -f ($condition + ".outColorR") ($plusMinus + ".input1D[1]");
	
				setAttr ($condition + ".operation") 4;
				setAttr ($condition + ".secondTerm") 1;
				setAttr ($plusMinus + ".operation") 2;
	
				connectAttr -f ($sphereGrp + ".taperSphere_" + $evoNum + "_" + ($i+1) + "_" + ($e+1)) ($condition + ".firstTerm");
				connectAttr -f ($plusMinus + ".output1D") ($path + ".uValue");

				rename $titleSphere[0] ("taperSphere_" + $evoNum + "_" + ($i+1) + "_" + ($e+1));
				rename $titleSphere[1] ("makeTaperSphere_" + $evoNum + "_" + ($i+1) + "_" + ($e+1));

				$sphereINC++;
			}
			
			parent $taperGrp $sphereGrp;
			rename $taperGrp ("taperSphereGrp_" + $evoNum + "_" + ($i+1));
		}

		float $sphereCycle = $sphereNum/2;
		if( $sphereNum % 2 != 0)
		{
			$sphereCycle = $sphereCycle + .5	;
		}
	
		float $lineSlope = $minRad-$maxRad;
		if($sphereNum>2)
		{
			$lineSlope = ($minRad-$maxRad)/(1-$sphereCycle);
		}

		for($i=0;$i<$taperNum;$i++)
		{
			for($e=0;$e<$sphereCycle;$e++)
			{
				setAttr ("makeTaperSphere_" + $evoNum + "_" + ($i+1) + "_" + ($e+1) + ".radius") (($lineSlope*$e)+$minRad);
				setAttr ("makeTaperSphere_" + $evoNum + "_" + ($i+1) + "_" + ($sphereNum-$e) + ".radius") (($lineSlope*$e)+$minRad);
			}
		}

		if(`objExists taperSphereGrp` == 0)
		{
			$mainTaperGrp = `group -em`;
			xform -os -piv 0 0 0;
			parent $mainTaperGrp evoGrp;
			rename $mainTaperGrp taperSphereGrp;
		}

		parent $sphereGrp taperSphereGrp;
		rename $sphereGrp ("taperSphereGrp_" + $evoNum);

		torus_updateTextList;		$array = `listRelatives -c locatorGrp`;		$arraySize = `size($array)`;		if(`objExists taperSphereGrp` == 1)		{
			int $taperSphere[] = {};			for($I=1;$I<=$arraySize;$I++)			{
				if(`objExists ("taperSphereGrp_" + $I)` == 1)				{					$taperSphereSize = `size($taperSphere)`;					$taperSphere[$taperSphereSize] = $I;				}			}							$taperSphereGrp = `listRelatives -c taperSphereGrp`;
			$taperSphereSize = `size($taperSphere)`;
			for($I=1;$I<=$taperSphereSize;$I++)			{				while( $taperSphereGrp[ ($I-1) ] != ("taperSphereGrp_" + $taperSphere[($I-1)]) )				{					reorder -relative -1 ("taperSphereGrp_" + $taperSphere[($I-1)]);					$taperSphereGrp = `listRelatives -c taperSphereGrp`;				}			}		}

		$ttEvoJBTypeSel = `radioButtonGrp -q -sl tt_evoJBConnSel`;
		$ttDbl = `radioButtonGrp -q -sl tt_dblRadio`;
		if($jbEvoNum != 0)
		{
			evoPopulate($ttEvoJBTypeSel, $ttDbl, $evoNum, $jbNum, $evoShellNumbers, 1);
		}
		textScrollList -e -sii $evoNum torus_textList;
	}
	else
	{
		error("select one curve to set as motion path.");
	}		
}

//-----------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------

global proc torusTaperBeads()
{
	int $taperNumInt = `intSliderGrp -q -v torus_taperNum`;
	float $taperNum = $taperNumInt;
	int $sphereNumInt = `intSliderGrp -q -v torus_sphereNum`;
	float $sphereNum = $sphereNumInt;
	float $section = `floatSliderGrp -q -v torus_sphereSection`;
	float $animCycle = `floatSliderGrp -q -v torus_sphereAnimCycle`;
	float $minRad = `floatSliderGrp -q -v torus_sphereMinRad`;
	float $maxRad = `floatSliderGrp -q -v torus_sphereMaxRad`;
	float $taperCenter = `floatSliderGrp -q -v torus_taperCenter`;
	float $taperCurvePos = `floatSliderGrp -q -v torus_taperCurvePos`;

	int $evoNumArray[] = `textScrollList -q -sii torus_textList`;
	$evoNum = $evoNumArray[0];
	if(`objExists ("taperSphereGrp_" + $evoNum)` == 1)
	{
		evoTaperCreate($taperNum, $sphereNum, $section, $animCycle, $minRad, $maxRad, $evoNum, $taperCenter, $taperCurvePos);
	}
}

//-----------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------

global proc torusTaperBeadsButton()
{
	int $taperNumInt = `intSliderGrp -q -v torus_taperNum`;
	float $taperNum = $taperNumInt;
	int $sphereNumInt = `intSliderGrp -q -v torus_sphereNum`;
	float $sphereNum = $sphereNumInt;
	float $section = `floatSliderGrp -q -v torus_sphereSection`;
	float $animCycle = `floatSliderGrp -q -v torus_sphereAnimCycle`;
	float $minRad = `floatSliderGrp -q -v torus_sphereMinRad`;
	float $maxRad = `floatSliderGrp -q -v torus_sphereMaxRad`;
	float $taperCenter = `floatSliderGrp -q -v torus_taperCenter`;
	float $taperCurvePos = `floatSliderGrp -q -v torus_taperCurvePos`;

	int $evoNumArray[] = `textScrollList -q -sii torus_textList`;
	int $evoNum = 0;
	if($evoNumArray[0] != 0)
	{
		$evoNum = $evoNumArray[0];
	}

	if($evoNum != 0)
	{
		evoTaperCreate($taperNum, $sphereNum, $section, $animCycle, $minRad, $maxRad, $evoNum, $taperCenter, $taperCurvePos);
	}
}

//-----------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------

global proc torusTaperBeadsDelete()
{
	int $evoNumArray[] = `textScrollList -q -sii torus_textList`;
	int $evoNum = 0;
	if($evoNumArray[0] != 0)
	{
		$evoNum = $evoNumArray[0];
	}

	if($evoNum != 0)
	{
		evoTaperDelete($evoNum);
	}
}


//-----------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------


proc torus_extrudeCreate(int $evoNum)
{
	$extrudeRad = `floatSliderGrp -q -v tt_extrudeRadius`;
	if(`objExists extrudeGrp` == 0)
	{
		$extrudeMainGrp = `group -em`;
		xform -os -piv 0 0 0;
		parent $extrudeMainGrp evoGrp;
		rename $extrudeMainGrp extrudeGrp;
	}

	$circle = `circle -c 0 0 0 -nr 0 1 0 -sw 360 -r $extrudeRad -d 3 -ut 0 -tol 2.14944e-08 -s 8 -ch 1`;
	$evoExtrude = `extrude -ch true -rn false -po 0 -et 2 -ucp 1 -fpt 1 -upn 1 -rotation 0 -scale 1 -rsp 1 $circle[0] ("evoCurve_" + $evoNum)`;

	select -r $circle $evoExtrude[0];
	$extrudeGrp = `group`;
	xform -os -piv 0 0 0;
	parent $extrudeGrp extrudeGrp;
	rename $extrudeGrp ("evoExtrudeGrp_" + $evoNum);
}

global proc torus_extrude()
{
	int $evoNumArray[] = `textScrollList -q -sii torus_textList`;
	int $evoNum = 0;
	if($evoNumArray[0] != 0)
	{
		$evoNum = $evoNumArray[0];
	}

	torus_extrudeCreate($evoNum);
}

global proc updateExtrudeRadius()
{

}
	
//-----------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------

global proc tt_aimConst()
{
	int $grpSel[] = `textScrollList -q -sii torus_textList`;
	int $constCheck = `checkBoxGrp -q -v1 tt_aimCheckBox`;

	if($constCheck == 1 && $grpSel[0] != 0 && `objExists ("evoPlaneGrp_" + $grpSel[0])` == 1)
	{
		if(`objExists planeAim_CAMERA` == 0)
		{
			$cam = `camera -centerOfInterest 5 -focalLength 35 -lensSqueezeRatio 1 
				-cameraScale 1 -horizontalFilmAperture 1.41732 -horizontalFilmOffset 0 
				-verticalFilmAperture 0.94488 -verticalFilmOffset 0 -filmFit Fill -overscan 1 
				-motionBlur 0 -shutterAngle 144 -nearClipPlane 0.01 -farClipPlane 100000 
				-orthographic 0 -orthographicWidth 30`; 
			objectMoveCommand; 
			cameraMakeNode 1 "";

			rename $cam[0] planeAim_CAMERA;
		}

		$planeList = `listRelatives -c ("evoPlaneGrp_" + $grpSel[0])`;
		$listSize = `size($planeList)`;

		for($i=0;$i<$listSize;$i++)
		{
			select -r planeAim_CAMERA $planeList[$i];
			aimConstraint -offset 0 0 0 -weight 1 -aimVector 0 1 0 -upVector 0 1 0 -worldUpType "vector" -worldUpVector 0 1 0;
		}
	}
	else if($constCheck == 0 && $grpSel[0] != 0 && `objExists ("evoPlaneGrp_" + $grpSel[0])` == 1 && `objExists ("evoPlane_" + $grpSel[0] + "_1_aimConstraint1")` == 1)
	{
		$planeList = `listRelatives -c ("evoPlaneGrp_" + $grpSel[0])`;
		$listSize = `size($planeList)`;

		for($i=0;$i<$listSize;$i++)
		{
			delete ("evoPlane_" + $grpSel[0] + "_" + ($i+1) + "_aimConstraint1");
			setAttr ("evoPlane_" + $grpSel[0] + "_" + ($i+1) + ".rx") 0;
			setAttr ("evoPlane_" + $grpSel[0] + "_" + ($i+1) + ".ry") 0;
			setAttr ("evoPlane_" + $grpSel[0] + "_" + ($i+1) + ".rz") 0;
		}
	}
}

//-----------------------------------------------------------------------------------------------------

proc torus_hrAnimateLocal( int $grpNum, int $hrAnimate )
{
	if($hrAnimate == 1)
	{
		floatFieldGrp -e -en 0 torusSpecGrp;
		setAttr -lock 0 ("locatorGroup_" + $grpNum + ".heightRatio");
		setAttr -lock 0 ("locatorGroup_" + $grpNum + ".radius");
	}
	else
	{
		floatFieldGrp -e -en 1 torusSpecGrp;
		CBdeleteConnection ("locatorGroup_" + $grpNum + ".heightRatio");		CBdeleteConnection ("locatorGroup_" + $grpNum + ".radius");
		setAttr -lock 1 ("locatorGroup_" + $grpNum + ".heightRatio");
		setAttr -lock 1 ("locatorGroup_" + $grpNum + ".radius");

		$hr = `getAttr ("locatorGroup_" + $grpNum + ".heightRatio")`;
		$r = `getAttr ("locatorGroup_" + $grpNum + ".radius")`;
		floatFieldGrp -e -v1 $hr -v2 $r torusSpecGrp;
	}
}

//-----------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------

global proc torus_hrAnimate()
{
	int $grpSel[] = `textScrollList -q -sii torus_textList`;
	int $hrAnimate = `checkBoxGrp -q -v1 torus_hrAnimateCheck`;

	if($grpSel[0] != 0)
	{
		torus_hrAnimateLocal($grpSel[0], $hrAnimate);
	}
}

//-----------------------------------------------------------------------------------------------------

proc jb_populate(int $jbGrpSel, int $jbGrpNum, int $listSelect)
{
	if($jbGrpSel != 0 )
	{
		$curveNum = 0;
		$jbEvo = 0;

		if(`objExists curveGrp` == 1)
		{
			$evoCurves = `listRelatives -c curveGrp`;			$curveNum = `size($evoCurves)`;
		}

		if(`objExists jitterbug_LOCKED_groups` == 1)
		{
			textScrollList -e -ra ;

			for($a=1;$a<=$jbGrpNum;$a++)			{
				$shellList = `listRelatives -c ("jitterbug_" + $a + "_shell_group")`;				$shellNum = `size($shellList)`;				for($b=0;$b<$shellNum;$b++)				{
					if($shellList[$b] == ("group_" + $a + "_shell_" + $b))					{
						$textList = `textScrollList -q -ai torus_JBList`;						$lineNum = `size($textList)`;
						if($lineNum >= $a)
						{
							textScrollList -e -rii $a torus_JBList;
						}
	
						textScrollList -e -ap $a (" JB Group " + $a) torus_JBList;					}	
					else
					{
						for($c=1;$c<=$curveNum;$c++)						{							if($shellList[$b] == ("JB_" + $a + "_evoCurve_" + $c))							{
								$textList = `textScrollList -q -ai torus_JBList`;								$lineNum = `size($textList)`;
								if($lineNum >= $a)
								{
									textScrollList -e -rii $a torus_JBList;
								}
								textScrollList -e -ap $a (" JB Group " + $a + " - c.") torus_JBList;							}						}
					}				}				}
			$listSelect = 1;
			textScrollList -e -sii $jbGrpSel torus_JBList;
		}

		if(`objExists jitterbug_LOCKED_groups` == 1 && $listSelect == 1)
		{
			textScrollList -e -ra torus_shellList;

			$shellList = `listRelatives -c ("jitterbug_" + $jbGrpSel + "_shell_group")`;			$shellNum = `size($shellList)`;
	
			$shellCount = 0;
			for($b=0;$b<$shellNum;$b++)
			{
				if($shellList[$b] == ("group_" + $jbGrpSel + "_shell_" + $b))
				{
					$textList = `textScrollList -q -ai torus_shellList`;					$lineNum = `size($textList)`;
					if($lineNum >= ($b+1))
					{
						textScrollList -e -rii ($b+1) torus_shellList;
					}
					textScrollList -e -ap ($b+1) ("   Shell " + $b) torus_shellList;
					$shellCount++;
				}
				else
				{
					$jbEvo = 1;
				}
			}
		
			if($jbEvo == 1)
			{
				for($b=0;$b<$shellNum;$b++)
				{
					if($shellList[$b] != ("group_" + $jbGrpSel + "_shell_" + $b))
					{
						for($c=1;$c<=$curveNum;$c++)
						{
							if($shellList[$b] == ("JB_" + $jbGrpSel + "_evoCurve_" + $c))
							{
								$jbCurveList = `listRelatives -c ("JB_" + $jbGrpSel + "_evoCurve_" + $c)`;
								$jbCurveNum = `size($jbCurveList)`;
			
								for($d=0;$d<$jbCurveNum;$d++)
								{
									$e=0;
									int $jbShellNumArray[] = {};
		
									while($jbCurveList[$d] != ("evoCurve_" + $c + "_JB_" + $jbGrpSel + "_shell_" + $e))
									{
										$e++;
									}
						
									textScrollList -e -rii ($e+1) -ap ($e+1) ("   Shell " + $e + " - Curve " + $c) torus_shellList;
								}
							}
							else if($shellList[$b] == ("JB_" + $jbGrpSel + "_evoTorus_" + $c))
							{
								$jbTorusList = `listRelatives -c ("JB_" + $jbGrpSel + "_evoTorus_" + $c)`;
								$jbTorusNum = `size($jbTorusList)`;
			
								for($d=0;$d<$jbTorusNum;$d++)
								{
									$e=0;
									int $jbShellNumArray[] = {};
		
									while($jbTorusList[$d] != ("evoTorus_" + $c + "_JB_" + $jbGrpSel + "_shell_" + $e))
									{
										$e++;
									}
						
									textScrollList -e -rii ($e+1) -ap ($e+1) ("   Shell " + $e + " - Torus " + $c) torus_shellList;
								}
							}
							else if($shellList[$b] == ("JB_" + $jbGrpSel + "_evoTaper_" + $c))
							{
								$jbTaperList = `listRelatives -c ("JB_" + $jbGrpSel + "_evoTaper_" + $c)`;
								$jbTaperNum = `size($jbTaperList)`;
			
								for($d=0;$d<$jbTaperNum;$d++)
								{
									$e=0;
									int $jbShellNumArray[] = {};
		
									while($jbTaperList[$d] != ("evoTaper_" + $c + "_JB_" + $jbGrpSel + "_shell_" + $e))
									{
										$e++;
									}
						
									textScrollList -e -rii ($e+1) -ap ($e+1) ("   Shell " + $e + " - Taper " + $c) torus_shellList;
								}
							}
							else if($shellList[$b] == ("JB_" + $jbGrpSel + "_evoExtrude_" + $c))
							{
								$jbTaperList = `listRelatives -c ("JB_" + $jbGrpSel + "_evoExtrude_" + $c)`;
								$jbTaperNum = `size($jbTaperList)`;
			
								for($d=0;$d<$jbTaperNum;$d++)
								{
									$e=0;
									int $jbShellNumArray[] = {};
		
									while($jbTaperList[$d] != ("evoExtrude_" + $c + "_JB_" + $jbGrpSel + "_shell_" + $e))
									{
										$e++;
									}
						
									textScrollList -e -rii ($e+1) -ap ($e+1) ("   Shell " + $e + " - Extrd " + $c) torus_shellList;
								}
							}

						}
					}
				}
			}
			for($i=1;$i<=$shellCount;$i++)
			{
				textScrollList -e -sii $i torus_shellList;
			}
		}
	}
	else
	{
		textScrollList -e -ra torus_shellList;
	}
}

//-----------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------

global proc tt_shellPopulate()
{
	int $jbGrpSel = 0;
	int $jbGrp[] = `textScrollList -q -sii torus_JBList`;
	if(`size($jbGrp)` != 0)
	{
		$jbGrpSel = $jbGrp[0];
	}
	$jbGroups = `listRelatives -c jitterbug_LOCKED_groups`;
	$jbGrpSize = `size($jbGroups)`;
	jb_populate($jbGrpSel, $jbGrpSize, 1);
}

//-----------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------

global proc tt_jbExp()
{
	$jbCheck = `checkBoxGrp -q -v1 tt_JBcheck`;

	if($jbCheck == 1)
	{
		formLayout -edit	

		-attachForm tt_evoJBConnSel "top" 15
		-attachForm tt_evoJBConnSel "left" 470
		-attachNone tt_evoJBConnSel "bottom"
		-attachNone tt_evoJBConnSel "right"

		-attachForm tt_dblRadio "top" 35 
		-attachForm tt_dblRadio "left" 470
		-attachNone tt_dblRadio "bottom" 
		-attachNone tt_dblRadio "right"	

		-attachForm torus_JBList "top" 60 		-attachForm torus_JBList "left" 490		-attachNone torus_JBList "bottom" 		-attachNone torus_JBList "right"

		-attachForm torus_shellList "top" 60 		-attachControl torus_shellList "left" 10 torus_JBList		-attachNone torus_shellList "bottom" 		-attachNone torus_shellList "right"

		torusToolkitForm;		setParent ..;
	
		radioButtonGrp -e -vis 1 tt_evoJBConnSel;
		radioButtonGrp -e -vis 1 tt_dblRadio;
		textScrollList -e -vis 1 torus_JBList;
		textScrollList -e -vis 1 torus_shellList;
		button -e -vis 1 tt_jbConn;
		button -e -vis 1 tt_jbDis;

		tabLayout -e -w 795 winTab;
		window -e -w 795 lbs_scriptsWindow;

		$jbGroups = `listRelatives -c jitterbug_LOCKED_groups`;
		$jbGrpSize = `size($jbGroups)`;
		jb_populate($jbGrpSize, $jbGrpSize, 0);
		//updateJBconnection($jbGrpNum);
	}
	else
	{
		formLayout -edit

		-attachForm tt_evoJBConnSel "top" 15
		-attachForm tt_evoJBConnSel "left" 0
		-attachNone tt_evoJBConnSel "bottom"
		-attachNone tt_evoJBConnSel "right"

		-attachForm tt_dblRadio "top" 35 
		-attachForm tt_dblRadio "left" 0
		-attachNone tt_dblRadio "bottom" 
		-attachNone tt_dblRadio "right"	

		-attachForm torus_JBList "top" 30 		-attachForm torus_JBList "left" 0		-attachNone torus_JBList "bottom" 		-attachNone torus_JBList "right"

		-attachForm torus_shellList "top" 30 		-attachControl torus_shellList "left" 10 torus_JBList		-attachNone torus_shellList "bottom" 		-attachNone torus_shellList "right"

		torusToolkitForm;		setParent ..;
	
		radioButtonGrp -e -vis 0 tt_evoJBConnSel;
		radioButtonGrp -e -vis 0 tt_dblRadio;
		textScrollList -e -vis 0 torus_JBList;
		textScrollList -e -vis 0 torus_shellList;
		button -e -vis 0 tt_jbConn;
		button -e -vis 0 tt_jbDis;

		tabLayout -e -w 480 winTab;
		window -e -w 480 lbs_scriptsWindow;
	}

}

//-----------------------------------------------------------------------------------------------------

proc reorder_jbEvo(int $jbNum, int $evoNum, int $evoType)
{
	//Sets $evoName for group selection

	string $evoName;
	if($evoType == 0)
	{
		$evoName = "evoCurve_";
	}
	else if($evoType == 1)
	{
		$evoName = "evoSphere_";
	}
	else if($evoType == 2)
	{
		$evoName = "evoTorus_";
	}
	else if($evoType == 3)
	{
		$evoName = "evoPlane_";
	}
	else if($evoType == 4)
	{
		$evoName = "evoExtrude_";
	}
	else if($evoType == 5)
	{
		$evoName = "evoTaper_";
	}

	if(`objExists("JB_" + $jbNum + "_" + $evoName + $evoNum)` == 1)
	{
		//list of all jitterbug shells that could have evoCurve attached
		//these groups contain jitterbug triangular faces
 
		$jbShells = `listRelatives -c ("jitterbug_" + $jbNum + "_shell_group")`;
		$jbShellNum = `size($jbShells)`;

		//list of shells with evoCurves actually attached 
		//these groups only contain evoCurves

		$evoShells = `listRelatives -c ("JB_" + $jbNum + "_" + $evoName + $evoNum)`;
		int $evoShellInt[] = {};

		//loop to determine which shell numbers have evoCurves
		//only the shell numbers are added into an array

		for($a=0;$a<`size($evoShells)`;$a++)
		{
			for($b=0;$b<$jbShellNum;$b++)
			{
				if($evoShells[$a] == ($evoName + $evoNum + "_JB_" + $jbNum + "_shell_" + $b))
				{
					$evoShellInt[$a] = $b;
				}
			}	
		}
	
		int $evoShellLoop = `size($evoShellInt)`;
		int $newEvoShellInt[] = $evoShellInt;

		//loop to reorder shell numbers array into sequential order

		for($a=1;$a<$evoShellLoop;$a++)
		{
			for($b=1;$b<=($evoShellLoop-$a);$b++)
			{
				$evoShellInt = $newEvoShellInt;
				if( $evoShellInt[($a-1)] > $evoShellInt[($b+($a-1))] )
				{
					$newEvoShellInt[($a-1)] = $evoShellInt[($b+($a-1))];
					$newEvoShellInt[($b+($a-1))] = $evoShellInt[($a-1)];
				}
			}
		}
	
		$evoShellInt = $newEvoShellInt;

		//loop to reorder evoCurve shell groups using $evoShellLoop array with reordered shell numbers

		for($a=0;$a<$evoShellLoop;$a++)		{			while( $evoShells[$a] != ( $evoName + $evoNum + "_JB_" + $jbNum + "_shell_" + $evoShellInt[$a] ))			{				reorder -relative -1 ( $evoName + $evoNum + "_JB_" + $jbNum + "_shell_" + $evoShellInt[$a] );				$evoShells = `listRelatives -c ("JB_" + $jbNum + "_" + $evoName + $evoNum)`;			}		}
	}
	else
	{
		warning("JB_" + $jbNum + "_" + $evoName + $evoNum + " does not exist\n");
	}

}

//-----------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------

global proc tt_connectJB()
{
	int $evoNum[] = `textScrollList -q -sii torus_textList`;

	if($evoNum[0] != 0)
	{
		int $evoType = 0;
		if(`objExists ("evoSphereGrp_" + $evoNum[0])` == 1)
		{
			$evoType = 1;
		}
		if(`objExists ("evoTorusGrp_" + $evoNum[0])` == 1)
		{
			$evoType = 2;
		}
		if(`objExists ("evoPlaneGrp_" + $evoNum[0])` == 1)
		{
			$evoType = 3;
		}
		if(`objExists ("evoExtrudeGrp_" + $evoNum[0])` == 1)
		{
			$evoType = 4;
		}
		if(`objExists ("taperSphereGrp_" + $evoNum[0])` == 1)
		{
			$evoType = 5;
		}

		print("evo type selected: " + $evoType + "\n");

		$ttEvoJBTypeSel = `radioButtonGrp -q -sl tt_evoJBConnSel`;
		$ttDbl = `radioButtonGrp -q -sl tt_dblRadio`;

		$jbNum = `textScrollList -q -sii torus_JBList`;
		$shellList = `textScrollList -q -sii torus_shellList`;
		int $shells[] = {};

		for($i=0;$i<`size($shellList)`;$i++)
		{
			$shells[$i] = $shellList[$i] - 1;
		}
		
		evoPopulate($ttEvoJBTypeSel, $ttDbl, $evoNum[0], $jbNum[0], $shells, $evoType);
		reorder_jbEvo($jbNum[0], $evoNum[0], $evoType);

		textScrollList -e -da torus_JBList;
		jb_populate($jbNum[0], $jbNum[0], 1);
	}
	else
	{
		error("select a Curve Group from Torus Text List" + "\n");
	}
}

//-----------------------------------------------------------------------------------------------------

proc evoDisconnect(int $evoNum, int $jbNum, int $shells[], int $evoType)
{
	string $evoName;
	if($evoType == 0)
	{
		$evoName = "evoCurve_";
	}
	else if($evoType == 1)
	{
		$evoName = "evoTaper_";
	}
	else if($evoType == 2)
	{
		$evoName = "evoExtrude_";
	}

	for($a=0;$a<`size($shells)`;$a++)
	{
		delete ($evoName + $evoNum + "_JB_" + $jbNum + "_shell_" + $shells[$a]);
	}

	$groupChildren = `listRelatives -c ("JB_" + $jbNum + "_" + $evoName + $evoNum)`;
	if(`size($groupChildren)` == 0)
	{
		delete ("JB_" + $jbNum + "_" + $evoName + $evoNum);
	}
}

//-----------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------

global proc tt_disconnectJB()
{
	$evoNum = `textScrollList -q -sii torus_textList`;

	int $evoType = 0;
	if(`objExists ("taperSphereGrp_" + $evoNum[0])` == 1)
	{
		$evoType = 1;
	}
	if(`objExists ("evoExtrudeGrp_" + $evoNum[0])` == 1)
	{
		$evoType = 2;
	}

	$jbNum = `textScrollList -q -sii torus_JBList`;
	$shellList = `textScrollList -q -sii torus_shellList`;
	int $shells[] = {};

	for($i=0;$i<`size($shellList)`;$i++)
	{
		$shells[$i] = $shellList[$i] - 1;
	}

	evoDisconnect($evoNum[0], $jbNum[0], $shells, $evoType);
	//reorder_jbEvo($jbNum[0], $evoNum[0], $evoType);

	textScrollList -e -da torus_JBList;
	jb_populate($jbNum[0], $jbNum[0], 1);
}